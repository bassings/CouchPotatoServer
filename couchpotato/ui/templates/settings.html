{% extends "base.html" %}
{% block title %}Settings — CouchPotato{% endblock %}
{% block content %}
<div class="p-4 lg:p-8 fade-in" x-data="settingsPanel()" x-init="init()">
  <div class="flex items-center justify-between mb-6">
    <h1 class="text-xl font-semibold tracking-tight">Settings</h1>
    <div class="flex items-center gap-3">
      <template x-if="activeTab !== 'logs'">
        <label class="flex items-center gap-2 cursor-pointer text-xs text-cp-muted">
          <button @click="showAdvanced = !showAdvanced"
                  :class="showAdvanced ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                  class="relative w-8 h-4 rounded-full transition-colors shrink-0">
            <span :class="showAdvanced ? 'translate-x-4' : 'translate-x-0.5'"
                  class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
          </button>
          <span :class="showAdvanced ? 'text-cp-accent' : ''">Advanced</span>
        </label>
      </template>
      <template x-if="activeTab !== 'logs'">
        <button @click="saveAll()" :disabled="saving"
                class="px-4 py-1.5 rounded-md text-xs font-medium bg-cp-accent text-black hover:bg-cp-accentHover transition-colors disabled:opacity-50">
          <span x-show="!saving">Save Changes</span>
          <span x-show="saving">Saving…</span>
        </button>
      </template>
    </div>
  </div>

  <!-- Loading state -->
  <div x-show="loading" class="flex items-center justify-center py-20">
    <div class="flex items-center gap-3 text-cp-muted text-sm">
      <svg class="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
      Loading settings…
    </div>
  </div>

  <div x-show="!loading" x-cloak>
    <!-- Tabs -->
    <div class="flex flex-wrap gap-1 mb-6">
      <template x-for="tab in tabOrder" :key="tab">
        <button @click="activeTab = tab"
                :class="activeTab === tab ? 'bg-cp-accent text-white shadow-md' : 'bg-white/[0.06] text-cp-muted hover:text-cp-text hover:bg-white/[0.10]'"
                class="px-4 py-2 rounded-lg transition-all text-sm font-medium" x-text="tabLabels[tab] || tab"></button>
      </template>
    </div>

    <!-- ==================== LOGS TAB ==================== -->
    <div x-show="activeTab === 'logs'" x-data="logsPanel()" x-init="$watch('$root.activeTab', v => { if(v==='logs') init(); else stopAutoRefresh(); })">
      <div class="flex items-center gap-3 mb-4">
        <select x-model="logType" @change="refresh()"
                class="bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
          <option value="all">All</option>
          <option value="error">Errors</option>
          <option value="warning">Warnings</option>
          <option value="info">Info</option>
          <option value="debug">Debug</option>
        </select>
        <label class="flex items-center gap-2 cursor-pointer text-xs text-cp-muted">
          <input type="checkbox" x-model="autoRefresh" @change="toggleAutoRefresh()"
                 class="rounded border-white/[0.1] bg-white/[0.03] text-cp-accent focus:ring-cp-accent/30">
          Auto-refresh
        </label>
        <button @click="refresh()" class="px-3 py-1.5 rounded-md text-xs font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors">
          Refresh
        </button>
        <button @click="clearLogs()" class="px-3 py-1.5 rounded-md text-xs font-medium bg-cp-danger/10 text-cp-danger hover:bg-cp-danger/20 transition-colors">
          Clear
        </button>
      </div>

      <div x-show="logLoading && logs.length === 0" class="flex items-center justify-center py-20">
        <div class="flex items-center gap-3 text-cp-muted text-sm">
          <svg class="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
          Loading logs…
        </div>
      </div>

      <div class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden font-mono text-[11px] leading-relaxed">
        <div class="max-h-[calc(100vh-280px)] overflow-y-auto" id="log-container">
          <template x-if="logs.length === 0 && !logLoading">
            <div class="px-4 py-8 text-center text-cp-muted text-xs">No log entries found.</div>
          </template>
          <template x-for="(entry, idx) in logs" :key="idx">
            <div class="px-4 py-1.5 border-b border-white/[0.02] hover:bg-white/[0.02] transition-colors"
                 :class="{
                   'text-cp-danger bg-cp-danger/[0.03]': entry.type === 'ERROR',
                   'text-cp-warning bg-cp-warning/[0.03]': entry.type === 'WARNING',
                   'text-cp-text': entry.type === 'INFO',
                   'text-cp-muted': entry.type === 'DEBUG',
                 }">
              <span class="text-cp-muted/50 select-none" x-text="entry.time"></span>
              <span class="inline-block w-14 text-center font-medium"
                    :class="{
                      'text-cp-danger': entry.type === 'ERROR',
                      'text-cp-warning': entry.type === 'WARNING',
                      'text-cp-accent': entry.type === 'INFO',
                      'text-cp-muted': entry.type === 'DEBUG',
                    }" x-text="entry.type"></span>
              <span class="text-cp-muted/70" x-text="'[' + entry.source + ']'"></span>
              <span x-text="entry.message"></span>
            </div>
          </template>
        </div>
      </div>
    </div>

    <!-- ==================== SETTINGS TABS ==================== -->
    <div x-show="activeTab !== 'logs'" class="space-y-4">
      <template x-for="(group, groupIdx) in currentGroups" :key="groupIdx">
        <div x-show="!group.advanced || showAdvanced" class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden">
            <!-- Group header -->
            <div class="flex items-center justify-between px-5 py-3"
                 :class="[
                   isGroupOpen(groupKey(group, groupIdx)) && (getEnabler(group) ? isEnabled(group) : true) ? 'border-b border-white/[0.04]' : '',
                   getEnabler(group) ? 'cursor-pointer' : ''
                 ]"
                 @click="getEnabler(group) && toggleGroup(groupKey(group, groupIdx))">
              <div class="flex items-center gap-3">
                <!-- Enabler toggle if group has one -->
                <template x-if="getEnabler(group)">
                  <button @click.stop="toggleEnabler(group)"
                          :class="isEnabled(group) ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                          class="relative w-8 h-4 rounded-full transition-colors shrink-0">
                    <span :class="isEnabled(group) ? 'translate-x-4' : 'translate-x-0.5'"
                          class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
                  </button>
                </template>
                <div>
                  <h3 class="text-sm font-medium" x-text="group.label || group.name"></h3>
                  <p x-show="group.description" class="text-[11px] text-cp-muted mt-0.5" x-html="group.description"></p>
                </div>
              </div>
              <!-- Only show chevron for groups with enabler (collapsible) -->
              <template x-if="getEnabler(group)">
                <svg class="w-4 h-4 text-cp-muted transition-transform" :class="isGroupOpen(groupKey(group, groupIdx)) ? 'rotate-180' : ''" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"/>
                </svg>
              </template>
            </div>

            <!-- Group options: always visible for non-enabler groups, toggle for enabler groups -->
            <div x-show="getEnabler(group) ? isGroupOpen(groupKey(group, groupIdx)) : true" x-transition class="px-5 py-4">
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4">
                <template x-for="opt in getGroupOptions(group)" :key="group.section + '.' + opt.name">
                  <div x-show="opt.type !== 'enabler' && (showAdvanced || !opt.advanced) && isOptionVisible(opt, group)"
                       :class="opt.type === 'directory' || opt.type === 'directories' ? 'sm:col-span-2' : ''">
                    <label class="block text-xs text-cp-muted mb-1.5" x-text="opt.label || opt.name.replace(/_/g, ' ')"></label>

                    <!-- Bool / checkbox -->
                    <template x-if="opt.type === 'bool'">
                      <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox"
                               :checked="getVal(group.section, opt.name)"
                               @change="setVal(group.section, opt.name, $event.target.checked)"
                               class="rounded border-white/[0.1] bg-white/[0.03] text-cp-accent focus:ring-cp-accent/30">
                        <span class="text-[11px] text-cp-muted" x-html="opt.description || ''"></span>
                      </label>
                    </template>

                    <!-- Dropdown -->
                    <template x-if="opt.type === 'dropdown'">
                      <div>
                        <select @change="setVal(group.section, opt.name, $event.target.value)"
                                class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                          <template x-for="v in (opt.values || [])" :key="JSON.stringify(v)">
                            <option :value="Array.isArray(v) ? v[1] : v"
                                    :selected="String(getVal(group.section, opt.name)) === String(Array.isArray(v) ? v[1] : v)"
                                    x-text="Array.isArray(v) ? v[0] : v"></option>
                          </template>
                        </select>
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Password -->
                    <template x-if="opt.type === 'password'">
                      <div>
                        <input type="password"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Int -->
                    <template x-if="opt.type === 'int' || opt.type === 'float'">
                      <div>
                        <input type="number" :step="opt.type === 'float' ? '0.1' : '1'"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Text (default) -->
                    <template x-if="!opt.type || opt.type === 'string' || opt.type === 'directory' || opt.type === 'directories'">
                      <div>
                        <input type="text"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               :placeholder="opt.default != null ? String(opt.default) : ''"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>
                  </div>
                </template>
              </div>

              <!-- Test button for providers -->
              <template x-if="group.list">
                <div class="mt-4 pt-3 border-t border-white/[0.04]">
                  <button @click="testProvider(group)" :disabled="testing === group.section"
                          class="px-3 py-1.5 rounded-md text-[11px] font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors disabled:opacity-50">
                    <span x-show="testing !== group.section">Test <span x-text="group.label"></span></span>
                    <span x-show="testing === group.section">Testing…</span>
                  </button>
                  <span x-show="testResult[group.section]"
                        :class="testResult[group.section] === 'success' ? 'text-cp-success' : 'text-cp-danger'"
                        class="ml-2 text-[11px]" x-text="testResult[group.section]"></span>
                </div>
              </template>
            </div>
          </div>
      </template>
    </div>
  </div>

  <!-- Restart banner -->
  <div x-show="needsRestart" x-transition class="fixed bottom-4 left-1/2 -translate-x-1/2 z-50 flex items-center gap-3 px-5 py-3 rounded-lg bg-cp-warning/20 border border-cp-warning/30 backdrop-blur-sm">
    <span class="text-xs text-cp-warning font-medium">Some changes need a restart to take effect.</span>
    <button @click="restartApp()" class="px-3 py-1 rounded-md text-xs font-medium bg-cp-warning text-black hover:opacity-90 transition-opacity">Restart</button>
  </div>

  <!-- Toast -->
  <div x-show="message" x-transition class="fixed bottom-4 right-4 lg:bottom-8 lg:right-8 z-50 px-4 py-2 rounded-md text-xs font-medium"
       :class="messageType === 'success' ? 'bg-cp-success/20 text-cp-success' : 'bg-cp-danger/20 text-cp-danger'"
       x-text="message"></div>
</div>

<script>
/* ── Logs panel (embedded in Settings) ── */
function logsPanel() {
  return {
    logs: [],
    logLoading: false,
    logType: 'all',
    autoRefresh: true,
    refreshTimer: null,

    async init() {
      await this.refresh();
      if (this.autoRefresh) this.startAutoRefresh();
    },

    async refresh() {
      this.logLoading = true;
      try {
        const typeParam = this.logType !== 'all' ? '&type=' + this.logType : '';
        const resp = await fetch(CP.apiBase + '/logging.partial/?limit=500' + typeParam);
        const data = await resp.json();
        if (data.success !== false) {
          this.logs = this.parseLogs(data.log || data.lines || []);
        }
      } catch (e) {
        console.error('Failed to load logs', e);
      }
      this.logLoading = false;
      this.$nextTick(() => {
        const el = document.getElementById('log-container');
        if (el) el.scrollTop = el.scrollHeight;
      });
    },

    parseLogs(lines) {
      if (!Array.isArray(lines)) return [];
      return lines.map(line => {
        if (typeof line === 'object' && line.time) {
          const msg = line.message || '';
          const srcMatch = msg.match(/^\[([^\]]*)\]\s*(.*)/);
          return {
            time: line.time,
            type: (line.type || 'INFO').toUpperCase(),
            source: srcMatch ? srcMatch[1].trim() : '',
            message: srcMatch ? srcMatch[2] : msg,
          };
        }
        if (typeof line !== 'string') return { time: '', type: 'INFO', source: '', message: String(line) };
        const m = line.match(/^(\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\s+(ERROR|WARNING|INFO|DEBUG)\s+\[([^\]]*)\]\s*(.*)$/);
        if (m) return { time: m[1], type: m[2], source: m[3].trim(), message: m[4] };
        const levelMatch = line.match(/\b(ERROR|WARNING|INFO|DEBUG)\b/);
        return { time: '', type: levelMatch ? levelMatch[1] : 'INFO', source: '', message: line };
      });
    },

    async clearLogs() {
      try {
        await fetch(CP.apiBase + '/logging.clear/');
        this.logs = [];
      } catch (e) {
        console.error('Failed to clear logs');
      }
    },

    startAutoRefresh() {
      this.stopAutoRefresh();
      this.refreshTimer = setInterval(() => this.refresh(), 10000);
    },

    stopAutoRefresh() {
      if (this.refreshTimer) {
        clearInterval(this.refreshTimer);
        this.refreshTimer = null;
      }
    },

    toggleAutoRefresh() {
      if (this.autoRefresh) this.startAutoRefresh();
      else this.stopAutoRefresh();
    },
  };
}

/* ── Settings panel ── */
function settingsPanel() {
  return {
    activeTab: 'general',
    loading: true,
    saving: false,
    showAdvanced: false,
    needsRestart: false,
    testing: null,
    testResult: {},
    message: '',
    messageType: 'success',
    openGroups: {},
    options: {},
    values: {},
    dirty: {},
    tabOrder: [],
    currentGroups: [],

    // Obsolete/dead sections to hide
    hiddenSections: new Set([
      'wdtvlive', 'windowsmediacenter', 'sonyps3', 'mediabrowser',
      'pneumatic', 'hadouken', 'homey',
      // Dead/defunct torrent trackers
      'awesomehd', 'bithdtv', 'scenetime', 'torrentbytes',
    ]),

    // Tabs to hide (no useful visible content)
    hiddenTabs: new Set(['providers', 'automation']),

    // Remap automation tab groups into suggestions (display) tab
    tabRemaps: { 'automation': 'display' },

    tabLabels: {
      general: 'General',
      downloaders: 'Downloaders',
      searcher: 'Searchers',
      renamer: 'Renamer',
      notifications: 'Notifications',
      manage: 'Library',
      display: 'Suggestions',
      providers: 'Providers',
      logs: 'Logs',
    },

    async init() {
      try {
        const resp = await fetch(CP.apiBase + '/settings/');
        const data = await resp.json();
        this.options = data.options || {};
        this.values = data.values || {};

        // Determine tab order from the data
        const tabSet = new Set();
        const tabOrderMap = {};
        for (const [sectionName, section] of Object.entries(this.options)) {
          if (this.hiddenSections.has(sectionName)) continue;
          for (const grp of (section.groups || [])) {
            const tab = grp.tab || 'general';
            tabSet.add(tab);
            if (section.order && (!tabOrderMap[tab] || section.order < tabOrderMap[tab])) {
              tabOrderMap[tab] = section.order;
            }
          }
        }

        const preferred = ['general', 'searcher', 'downloaders', 'renamer', 'notifications', 'automation', 'manage', 'display'];
        this.tabOrder = preferred.filter(t => tabSet.has(t) && !this.hiddenTabs.has(t));
        for (const t of tabSet) {
          if (!this.tabOrder.includes(t) && !this.hiddenTabs.has(t)) this.tabOrder.push(t);
        }
        // Add Logs tab at the end
        this.tabOrder.push('logs');

        // Smart auto-expand: essential settings visible, enabled sections open
        this.computeOpenGroups();
        this.updateCurrentGroups();
      } catch (e) {
        console.error('Failed to load settings', e);
        this.toast('Failed to load settings', 'error');
      }
      this.loading = false;
      this.$watch('activeTab', () => this.updateCurrentGroups());
    },

    computeOpenGroups() {
      for (const tab of this.tabOrder) {
        const groups = this.getTabGroups(tab);
        groups.forEach((group, idx) => {
          const key = this.groupKey(group, idx);
          const enabler = this.getEnabler(group);
          if (!enabler) {
            // No enabler = always open (not collapsible)
            this.openGroups[key] = true;
          } else if (this.isEnabled(group)) {
            // Has enabler and ON = expand to show options
            this.openGroups[key] = true;
          }
          // Enabler OFF = collapsed, just shows the toggle
        });
      }
    },

    updateCurrentGroups() {
      this.currentGroups = this.getTabGroups(this.activeTab);
    },

    groupKey(group, idx) {
      return group.section + '.' + (group.name || 'default') + '.' + (idx || 0);
    },

    getTabGroups(tab) {
      const groups = [];
      for (const [sectionName, section] of Object.entries(this.options)) {
        if (this.hiddenSections.has(sectionName)) continue;
        for (const grp of (section.groups || [])) {
          let originalTab = grp.tab || 'general';
          let grpTab = this.tabRemaps[originalTab] || originalTab;
          if (grpTab === tab) {
            groups.push({ ...grp, section: sectionName, order: section.order || 999, _originalTab: originalTab });
          }
        }
      }
      groups.sort((a, b) => a.order - b.order);
      return groups;
    },

    getGroupOptions(group) {
      return (group.options || []).map(opt => ({
        ...opt,
        label: opt.label || null,
      }));
    },

    isOptionVisible(opt, group) {
      if (!opt.show_when) return true;
      for (const [key, expected] of Object.entries(opt.show_when)) {
        const [sec, name] = key.split('.');
        const val = this.getVal(sec, name);
        const boolVal = val === true || val === 'True' || val === '1' || val === 1 || val === 'true';
        if (expected === true && !boolVal) return false;
        if (expected === false && boolVal) return false;
        if (typeof expected !== 'boolean' && String(val) !== String(expected)) return false;
      }
      return true;
    },

    getEnabler(group) {
      return (group.options || []).find(o => o.type === 'enabler') || null;
    },

    isEnabled(group) {
      const enabler = this.getEnabler(group);
      if (!enabler) return true;
      const val = this.getVal(group.section, enabler.name);
      return val === true || val === 'True' || val === '1' || val === 1 || val === 'true';
    },

    toggleEnabler(group) {
      const enabler = this.getEnabler(group);
      if (!enabler) return;
      const newVal = !this.isEnabled(group);
      this.setVal(group.section, enabler.name, newVal);
      // Auto-expand when enabling, collapse when disabling
      const groups = this.currentGroups;
      const idx = groups.indexOf(group);
      if (idx >= 0) {
        const key = this.groupKey(group, idx);
        this.openGroups[key] = newVal;
      }
    },

    getVal(section, name) {
      const key = section + '.' + name;
      if (key in this.dirty) return this.dirty[key];
      if (this.values[section] && this.values[section][name] !== undefined) {
        return this.values[section][name];
      }
      return '';
    },

    setVal(section, name, value) {
      const key = section + '.' + name;
      this.dirty[key] = value;
    },

    toggleGroup(key) {
      this.openGroups[key] = !this.openGroups[key];
    },

    isGroupOpen(key) {
      return !!this.openGroups[key];
    },

    async saveAll() {
      this.saving = true;
      let restartNeeded = false;
      try {
        const saves = Object.entries(this.dirty).map(([key, value]) => {
          const [section, ...nameParts] = key.split('.');
          const name = nameParts.join('.');
          const params = new URLSearchParams();
          params.append('section', section);
          params.append('name', name);
          params.append('value', typeof value === 'boolean' ? (value ? '1' : '0') : String(value));
          return fetch(CP.apiBase + '/settings.save/?' + params.toString());
        });
        await Promise.all(saves);
        for (const [key, value] of Object.entries(this.dirty)) {
          const [section, ...nameParts] = key.split('.');
          const name = nameParts.join('.');
          if (!this.values[section]) this.values[section] = {};
          this.values[section][name] = value;
        }
        const restartKeys = ['core.port', 'core.ssl_cert', 'core.ssl_key', 'core.username', 'core.password'];
        restartNeeded = Object.keys(this.dirty).some(k => restartKeys.includes(k));
        this.dirty = {};
        this.toast('Settings saved!', 'success');
        if (restartNeeded) this.needsRestart = true;
      } catch (e) {
        this.toast('Failed to save: ' + e.message, 'error');
      }
      this.saving = false;
    },

    async testProvider(group) {
      this.testing = group.section;
      this.testResult[group.section] = '';
      try {
        const resp = await fetch(CP.apiBase + '/' + group.section + '.test/');
        const data = await resp.json();
        this.testResult[group.section] = data.success ? 'success' : (data.message || 'failed');
      } catch (e) {
        this.testResult[group.section] = 'error';
      }
      this.testing = null;
    },

    async restartApp() {
      try {
        await fetch(CP.apiBase + '/app.restart/');
        this.toast('Restarting…', 'success');
        this.needsRestart = false;
        setTimeout(() => location.reload(), 5000);
      } catch (e) {
        this.toast('Restart failed', 'error');
      }
    },

    toast(msg, type) {
      this.message = msg;
      this.messageType = type;
      setTimeout(() => this.message = '', 3000);
    },
  };
}
</script>
{% endblock %}
