{% extends "base.html" %}
{% block title %}Settings — CouchPotato{% endblock %}
{% block content %}
<div class="p-4 lg:p-8 fade-in" x-data="settingsPanel()" x-init="init()">
  <div class="flex items-center justify-between mb-6">
    <h1 class="text-xl font-semibold tracking-tight">Settings</h1>
    <div class="flex items-center gap-3">
      <template x-if="activeTab !== 'logs'">
        <label class="flex items-center gap-2 cursor-pointer text-xs text-cp-muted">
          <button @click="showAdvanced = !showAdvanced"
                  :class="showAdvanced ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                  class="relative w-8 h-4 rounded-full transition-colors shrink-0">
            <span :class="showAdvanced ? 'translate-x-4' : 'translate-x-0.5'"
                  class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
          </button>
          <span :class="showAdvanced ? 'text-cp-accent' : ''">Advanced</span>
        </label>
      </template>
      <template x-if="activeTab !== 'logs'">
        <button @click="saveAll()" :disabled="saving"
                class="px-4 py-1.5 rounded-md text-xs font-medium bg-cp-accent text-black hover:bg-cp-accentHover transition-colors disabled:opacity-50">
          <span x-show="!saving">Save Changes</span>
          <span x-show="saving">Saving…</span>
        </button>
      </template>
    </div>
  </div>

  <!-- Loading state -->
  <div x-show="loading" class="flex items-center justify-center py-20">
    <div class="flex items-center gap-3 text-cp-muted text-sm">
      <svg class="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
      Loading settings…
    </div>
  </div>

  <div x-show="!loading" x-cloak>
    <!-- Tabs -->
    <div class="flex flex-wrap gap-1 mb-6 overflow-x-auto scrollbar-hide">
      <template x-for="tab in tabOrder" :key="tab">
        <button @click="activeTab = tab"
                :class="activeTab === tab ? 'bg-cp-accent text-white shadow-md' : 'bg-white/[0.06] text-cp-muted hover:text-cp-text hover:bg-white/[0.10]'"
                class="px-4 py-2 rounded-lg transition-all text-sm font-medium" x-text="tabLabels[tab] || tab"></button>
      </template>
    </div>

    <!-- ==================== LOGS TAB ==================== -->
    <div x-show="activeTab === 'logs'" x-data="logsPanel()" x-init="$watch('$root.activeTab', v => { if(v==='logs') init(); else stopAutoRefresh(); })">
      <div class="flex items-center gap-3 mb-4">
        <select x-model="logType" @change="refresh()"
                class="bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
          <option value="all">All</option>
          <option value="error">Errors</option>
          <option value="warning">Warnings</option>
          <option value="info">Info</option>
          <option value="debug">Debug</option>
        </select>
        <label class="flex items-center gap-2 cursor-pointer text-xs text-cp-muted">
          <input type="checkbox" x-model="autoRefresh" @change="toggleAutoRefresh()"
                 class="rounded border-white/[0.1] bg-white/[0.03] text-cp-accent focus:ring-cp-accent/30">
          Auto-refresh
        </label>
        <button @click="refresh()" class="px-3 py-1.5 rounded-md text-xs font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors">
          Refresh
        </button>
        <button @click="clearLogs()" class="px-3 py-1.5 rounded-md text-xs font-medium bg-cp-danger/10 text-cp-danger hover:bg-cp-danger/20 transition-colors">
          Clear
        </button>
      </div>

      <div x-show="logLoading && logs.length === 0" class="flex items-center justify-center py-20">
        <div class="flex items-center gap-3 text-cp-muted text-sm">
          <svg class="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
          Loading logs…
        </div>
      </div>

      <div class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden font-mono text-[11px] leading-relaxed">
        <div class="max-h-[calc(100vh-280px)] overflow-y-auto" id="log-container">
          <template x-if="logs.length === 0 && !logLoading">
            <div class="px-4 py-8 text-center text-cp-muted text-xs">No log entries found.</div>
          </template>
          <template x-for="(entry, idx) in logs" :key="idx">
            <div class="px-4 py-1.5 border-b border-white/[0.02] hover:bg-white/[0.02] transition-colors"
                 :class="{
                   'text-cp-danger bg-cp-danger/[0.03]': entry.type === 'ERROR',
                   'text-cp-warning bg-cp-warning/[0.03]': entry.type === 'WARNING',
                   'text-cp-text': entry.type === 'INFO',
                   'text-cp-muted': entry.type === 'DEBUG',
                 }">
              <span class="text-cp-muted/50 select-none" x-text="entry.time"></span>
              <span class="inline-block w-14 text-center font-medium"
                    :class="{
                      'text-cp-danger': entry.type === 'ERROR',
                      'text-cp-warning': entry.type === 'WARNING',
                      'text-cp-accent': entry.type === 'INFO',
                      'text-cp-muted': entry.type === 'DEBUG',
                    }" x-text="entry.type"></span>
              <span class="text-cp-muted/70" x-text="'[' + entry.source + ']'"></span>
              <span x-text="entry.message"></span>
            </div>
          </template>
        </div>
      </div>
    </div>

    <!-- ==================== SETTINGS TABS ==================== -->
    <div x-show="activeTab !== 'logs'" class="space-y-4">
      <template x-for="(group, groupIdx) in currentGroups" :key="groupIdx">
        <div x-show="!group.advanced || showAdvanced" class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden max-w-full">
            <!-- Group header -->
            <div class="flex items-center justify-between px-5 py-3"
                 :class="[
                   isGroupOpen(groupKey(group, groupIdx)) && (getEnabler(group) ? isEnabled(group) : true) ? 'border-b border-white/[0.04]' : '',
                   getEnabler(group) ? 'cursor-pointer' : ''
                 ]"
                 @click="getEnabler(group) && toggleGroup(groupKey(group, groupIdx))">
              <div class="flex items-center gap-3">
                <!-- Enabler toggle if group has one -->
                <template x-if="getEnabler(group)">
                  <button @click.stop="toggleEnabler(group)"
                          :class="isEnabled(group) ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                          class="relative w-8 h-4 rounded-full transition-colors shrink-0">
                    <span :class="isEnabled(group) ? 'translate-x-4' : 'translate-x-0.5'"
                          class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
                  </button>
                </template>
                <div>
                  <h3 class="text-sm font-medium" x-text="group.label || group.name"></h3>
                  <p x-show="group.description" class="text-[11px] text-cp-muted mt-0.5" x-html="group.description"></p>
                </div>
              </div>
              <!-- Only show chevron for groups with enabler (collapsible) -->
              <template x-if="getEnabler(group)">
                <svg class="w-4 h-4 text-cp-muted transition-transform" :class="isGroupOpen(groupKey(group, groupIdx)) ? 'rotate-180' : ''" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"/>
                </svg>
              </template>
            </div>

            <!-- Group options: always visible for non-enabler groups, toggle for enabler groups -->
            <div x-show="getEnabler(group) ? isGroupOpen(groupKey(group, groupIdx)) : true" x-transition class="px-5 py-4 overflow-hidden">
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4 overflow-hidden">
                <template x-for="opt in getGroupOptions(group)" :key="group.section + '.' + opt.name">
                  <div x-show="opt.type !== 'enabler' && (showAdvanced || !opt.advanced) && isOptionVisible(opt, group)"
                       :class="opt.type === 'directory' || opt.type === 'directories' ? 'sm:col-span-2' : ''">
                    <label class="block text-xs text-cp-muted mb-1.5" x-text="opt.label || opt.name.replace(/_/g, ' ')"></label>

                    <!-- Bool / checkbox -->
                    <template x-if="opt.type === 'bool'">
                      <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox"
                               :checked="getVal(group.section, opt.name)"
                               @change="setVal(group.section, opt.name, $event.target.checked)"
                               class="rounded border-white/[0.1] bg-white/[0.03] text-cp-accent focus:ring-cp-accent/30">
                        <span class="text-[11px] text-cp-muted" x-html="opt.description || ''"></span>
                      </label>
                    </template>

                    <!-- Dropdown -->
                    <template x-if="opt.type === 'dropdown'">
                      <div>
                        <select @change="setVal(group.section, opt.name, $event.target.value)"
                                class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                          <template x-for="v in (opt.values || [])" :key="JSON.stringify(v)">
                            <option :value="Array.isArray(v) ? v[1] : v"
                                    :selected="String(getVal(group.section, opt.name)) === String(Array.isArray(v) ? v[1] : v)"
                                    x-text="Array.isArray(v) ? v[0] : v"></option>
                          </template>
                        </select>
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Password -->
                    <template x-if="opt.type === 'password'">
                      <div>
                        <input type="password"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Int -->
                    <template x-if="opt.type === 'int' || opt.type === 'float'">
                      <div>
                        <input type="number" :step="opt.type === 'float' ? '0.1' : '1'"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Button (action button like Jackett sync) -->
                    <template x-if="opt.type === 'button'">
                      <div class="sm:col-span-2" x-data="buttonField(group.section, opt)">
                        <button @click="execute()" :disabled="running"
                                class="px-4 py-2 rounded-md text-xs font-medium bg-cp-accent/20 text-cp-accent hover:bg-cp-accent/30 transition-colors disabled:opacity-50">
                          <span x-show="!running" x-text="opt.button_text || 'Execute'"></span>
                          <span x-show="running" class="flex items-center gap-2">
                            <svg class="w-3 h-3 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
                            Running…
                          </span>
                        </button>
                        <div x-show="result" class="mt-2 text-xs" :class="success ? 'text-cp-success' : 'text-cp-danger'" x-text="result"></div>
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>

                    <!-- Combined (multi-entry rows like newznab hosts/keys) -->
                    <template x-if="opt.type === 'combined'">
                      <div class="sm:col-span-2" x-data="combinedField(group.section, opt)">
                        <!-- Column headers -->
                        <div class="flex gap-2 mb-2 items-center text-[10px] text-cp-muted/60 font-medium">
                          <template x-for="(col, colIdx) in opt.combine" :key="'hdr-'+colIdx">
                            <span :class="col === 'use' ? 'w-10 shrink-0 text-center' : 'flex-1 min-w-0'" x-text="col === 'use' ? '' : col.replace(/_/g, ' ')"></span>
                          </template>
                          <span class="w-4 shrink-0"></span>
                        </div>
                        <template x-for="(row, rowIdx) in rows" :key="rowIdx">
                          <div class="flex gap-2 mb-2 items-center">
                            <template x-for="(col, colIdx) in opt.combine" :key="colIdx">
                              <div :class="col === 'use' ? 'w-10 shrink-0 flex justify-center' : 'flex-1 min-w-0'">
                                <!-- Toggle for 'use' column -->
                                <template x-if="col === 'use'">
                                  <button @click="updateRow(rowIdx, colIdx, (row[colIdx] === '1' || row[colIdx] === 1) ? '0' : '1')"
                                          :class="(row[colIdx] === '1' || row[colIdx] === 1) ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                                          class="relative w-8 h-4 rounded-full transition-colors shrink-0">
                                    <span :class="(row[colIdx] === '1' || row[colIdx] === 1) ? 'translate-x-4' : 'translate-x-0.5'"
                                          class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
                                  </button>
                                </template>
                                <!-- Text input for other columns -->
                                <template x-if="col !== 'use'">
                                  <input type="text" :placeholder="col.replace(/_/g, ' ')"
                                         :value="row[colIdx] || ''"
                                         @input="updateRow(rowIdx, colIdx, $event.target.value)"
                                         class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
                                </template>
                              </div>
                            </template>
                            <button @click="removeRow(rowIdx)" class="text-cp-muted hover:text-cp-danger transition-colors shrink-0" title="Remove">
                              <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                          </div>
                        </template>
                        <button @click="addRow()" class="text-[11px] text-cp-accent hover:text-cp-accentHover transition-colors">+ Add</button>
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="typeof opt.description === 'object' ? Object.values(opt.description).join(' ') : (opt.description || '')"></p>
                      </div>
                    </template>

                    <!-- Directories (multi-path) -->
                    <template x-if="opt.type === 'directories'">
                      <div class="sm:col-span-2" x-data="directoriesField(group.section, opt)">
                        <template x-for="(dir, dirIdx) in dirs" :key="dirIdx">
                          <div class="flex gap-2 mb-2 items-center">
                            <input type="text" :value="dir"
                                   @input="updateDir(dirIdx, $event.target.value)"
                                   placeholder="/path/to/movies"
                                   class="flex-1 bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
                            <button @click="removeDir(dirIdx)" class="text-cp-muted hover:text-cp-danger transition-colors shrink-0" title="Remove">
                              <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                          </div>
                        </template>
                        <button @click="addDir()" class="text-[11px] text-cp-accent hover:text-cp-accentHover transition-colors">+ Add folder</button>
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description || ''"></p>
                      </div>
                    </template>

                    <!-- Text (default) -->
                    <template x-if="!opt.type || opt.type === 'string' || opt.type === 'directory'">
                      <div>
                        <input type="text"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               :placeholder="opt.default != null ? String(opt.default) : ''"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p x-show="opt.description" class="text-[10px] text-cp-muted/60 mt-1" x-html="opt.description"></p>
                      </div>
                    </template>
                  </div>
                </template>
              </div>

              <!-- Test button for providers -->
              <template x-if="group.list">
                <div class="mt-4 pt-3 border-t border-white/[0.04]">
                  <button @click="testProvider(group)" :disabled="testing === group.section"
                          class="px-3 py-1.5 rounded-md text-[11px] font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors disabled:opacity-50">
                    <span x-show="testing !== group.section">Test <span x-text="group.label"></span></span>
                    <span x-show="testing === group.section">Testing…</span>
                  </button>
                  <!-- Simple result for single-entry providers -->
                  <span x-show="testResult[group.section] && !testResultDetails[group.section]"
                        :class="testResult[group.section] === 'success' ? 'text-cp-success' : 'text-cp-danger'"
                        class="ml-2 text-[11px]" x-text="testResult[group.section]"></span>
                  <!-- Detailed results for multi-entry providers -->
                  <div x-show="testResultDetails[group.section]" class="mt-2 space-y-1">
                    <template x-for="(detail, idx) in (testResultDetails[group.section] || [])" :key="idx">
                      <div class="flex items-center gap-2 text-[11px]">
                        <span :class="detail.success ? 'text-cp-success' : 'text-cp-danger'" class="shrink-0">
                          <template x-if="detail.success">✓</template>
                          <template x-if="!detail.success">✗</template>
                        </span>
                        <span class="text-cp-muted truncate" x-text="detail.host"></span>
                        <span x-show="detail.error" class="text-cp-danger/70 truncate" x-text="detail.error"></span>
                      </div>
                    </template>
                  </div>
                </div>
              </template>
            </div>
          </div>
      </template>
    </div>
  </div>

  <!-- Restart banner -->
  <div x-show="needsRestart" x-transition class="fixed bottom-4 left-1/2 -translate-x-1/2 z-50 flex items-center gap-3 px-5 py-3 rounded-lg bg-cp-warning/20 border border-cp-warning/30 backdrop-blur-sm">
    <span class="text-xs text-cp-warning font-medium">Some changes need a restart to take effect.</span>
    <button @click="restartApp()" class="px-3 py-1 rounded-md text-xs font-medium bg-cp-warning text-black hover:opacity-90 transition-opacity">Restart</button>
  </div>

  <!-- Toast -->
  <div x-show="message" x-transition class="fixed bottom-4 right-4 lg:bottom-8 lg:right-8 z-50 px-4 py-2 rounded-md text-xs font-medium"
       :class="messageType === 'success' ? 'bg-cp-success/20 text-cp-success' : 'bg-cp-danger/20 text-cp-danger'"
       x-text="message"></div>
</div>

<script>
/* ── Logs panel (embedded in Settings) ── */
function logsPanel() {
  return {
    logs: [],
    logLoading: false,
    logType: 'all',
    autoRefresh: true,
    refreshTimer: null,

    async init() {
      await this.refresh();
      if (this.autoRefresh) this.startAutoRefresh();
    },

    async refresh() {
      this.logLoading = true;
      try {
        const typeParam = this.logType !== 'all' ? '&type=' + this.logType : '';
        const resp = await fetch(CP.apiBase + '/logging.partial/?limit=500' + typeParam);
        const data = await resp.json();
        if (data.success !== false) {
          this.logs = this.parseLogs(data.log || data.lines || []);
        }
      } catch (e) {
        console.error('Failed to load logs', e);
      }
      this.logLoading = false;
      this.$nextTick(() => {
        const el = document.getElementById('log-container');
        if (el) el.scrollTop = el.scrollHeight;
      });
    },

    parseLogs(lines) {
      if (!Array.isArray(lines)) return [];
      return lines.map(line => {
        if (typeof line === 'object' && line.time) {
          const msg = line.message || '';
          const srcMatch = msg.match(/^\[([^\]]*)\]\s*(.*)/);
          return {
            time: line.time,
            type: (line.type || 'INFO').toUpperCase(),
            source: srcMatch ? srcMatch[1].trim() : '',
            message: srcMatch ? srcMatch[2] : msg,
          };
        }
        if (typeof line !== 'string') return { time: '', type: 'INFO', source: '', message: String(line) };
        const m = line.match(/^(\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\s+(ERROR|WARNING|INFO|DEBUG)\s+\[([^\]]*)\]\s*(.*)$/);
        if (m) return { time: m[1], type: m[2], source: m[3].trim(), message: m[4] };
        const levelMatch = line.match(/\b(ERROR|WARNING|INFO|DEBUG)\b/);
        return { time: '', type: levelMatch ? levelMatch[1] : 'INFO', source: '', message: line };
      });
    },

    async clearLogs() {
      try {
        await fetch(CP.apiBase + '/logging.clear/');
        this.logs = [];
      } catch (e) {
        console.error('Failed to clear logs');
      }
    },

    startAutoRefresh() {
      this.stopAutoRefresh();
      this.refreshTimer = setInterval(() => this.refresh(), 10000);
    },

    stopAutoRefresh() {
      if (this.refreshTimer) {
        clearInterval(this.refreshTimer);
        this.refreshTimer = null;
      }
    },

    toggleAutoRefresh() {
      if (this.autoRefresh) this.startAutoRefresh();
      else this.stopAutoRefresh();
    },
  };
}

/* ── Settings panel ── */
function settingsPanel() {
  return {
    activeTab: 'general',
    loading: true,
    saving: false,
    showAdvanced: false,
    needsRestart: false,
    testing: null,
    testResult: {},
    testResultDetails: {},
    message: '',
    messageType: 'success',
    openGroups: {},
    options: {},
    values: {},
    dirty: {},
    tabOrder: [],
    currentGroups: [],

    // Obsolete/dead sections to hide
    hiddenSections: new Set([
      'wdtvlive', 'windowsmediacenter', 'sonyps3', 'mediabrowser',
      'pneumatic', 'hadouken', 'homey',
      // Dead/defunct torrent trackers
      'awesomehd', 'bithdtv', 'scenetime', 'torrentbytes',
    ]),

    // Tabs to hide (no useful visible content)
    hiddenTabs: new Set(['providers', 'automation']),

    // Remap automation tab groups into suggestions (display) tab
    tabRemaps: { 'automation': 'display' },

    tabLabels: {
      general: 'General',
      downloaders: 'Downloaders',
      searcher: 'Searchers',
      renamer: 'Renamer',
      notifications: 'Notifications',
      manage: 'Library',
      display: 'Suggestions',
      providers: 'Providers',
      logs: 'Logs',
    },

    async init() {
      try {
        const resp = await fetch(CP.apiBase + '/settings/');
        const data = await resp.json();
        this.options = data.options || {};
        this.values = data.values || {};

        // Determine tab order from the data
        const tabSet = new Set();
        const tabOrderMap = {};
        for (const [sectionName, section] of Object.entries(this.options)) {
          if (this.hiddenSections.has(sectionName)) continue;
          for (const grp of (section.groups || [])) {
            const tab = grp.tab || 'general';
            tabSet.add(tab);
            if (section.order && (!tabOrderMap[tab] || section.order < tabOrderMap[tab])) {
              tabOrderMap[tab] = section.order;
            }
          }
        }

        const preferred = ['general', 'searcher', 'downloaders', 'renamer', 'notifications', 'automation', 'manage', 'display'];
        this.tabOrder = preferred.filter(t => tabSet.has(t) && !this.hiddenTabs.has(t));
        for (const t of tabSet) {
          if (!this.tabOrder.includes(t) && !this.hiddenTabs.has(t)) this.tabOrder.push(t);
        }
        // Add Logs tab at the end
        this.tabOrder.push('logs');

        // Smart auto-expand: essential settings visible, enabled sections open
        this.computeOpenGroups();
        this.updateCurrentGroups();
      } catch (e) {
        console.error('Failed to load settings', e);
        this.toast('Failed to load settings', 'error');
      }
      this.loading = false;
      this.$watch('activeTab', () => this.updateCurrentGroups());
    },

    computeOpenGroups() {
      for (const tab of this.tabOrder) {
        const groups = this.getTabGroups(tab);
        groups.forEach((group, idx) => {
          const key = this.groupKey(group, idx);
          const enabler = this.getEnabler(group);
          if (!enabler) {
            // No enabler = always open (not collapsible)
            this.openGroups[key] = true;
          } else if (this.isEnabled(group)) {
            // Has enabler and ON = expand to show options
            this.openGroups[key] = true;
          }
          // Enabler OFF = collapsed, just shows the toggle
        });
      }
    },

    updateCurrentGroups() {
      this.currentGroups = this.getTabGroups(this.activeTab);
    },

    groupKey(group, idx) {
      return group.section + '.' + (group.name || 'default') + '.' + (idx || 0);
    },

    getTabGroups(tab) {
      const groups = [];
      for (const [sectionName, section] of Object.entries(this.options)) {
        if (this.hiddenSections.has(sectionName)) continue;
        for (const grp of (section.groups || [])) {
          let originalTab = grp.tab || 'general';
          let grpTab = this.tabRemaps[originalTab] || originalTab;
          if (grpTab === tab) {
            groups.push({ ...grp, section: sectionName, order: section.order || 999, _originalTab: originalTab });
          }
        }
      }
      groups.sort((a, b) => a.order - b.order);
      return groups;
    },

    getGroupOptions(group) {
      // Collect names consumed by combined fields so they can be hidden
      const combinedNames = new Set();
      for (const opt of (group.options || [])) {
        if (opt.type === 'combined' && opt.combine) {
          for (const col of opt.combine) {
            if (col !== opt.name) combinedNames.add(col);
          }
        }
      }
      return (group.options || [])
        .filter(opt => !combinedNames.has(opt.name))
        .map(opt => ({
          ...opt,
          label: opt.label || null,
        }));
    },

    isOptionVisible(opt, group) {
      if (!opt.show_when) return true;
      // Touch dirty to make Alpine reactive to changes
      const _dirty = JSON.stringify(this.dirty);
      for (const [key, expected] of Object.entries(opt.show_when)) {
        const [sec, name] = key.split('.');
        const val = this.getVal(sec, name);
        const boolVal = val === true || val === 'True' || val === '1' || val === 1 || val === 'true';
        if (expected === true && !boolVal) return false;
        if (expected === false && boolVal) return false;
        if (typeof expected !== 'boolean' && String(val) !== String(expected)) return false;
      }
      return true;
    },

    getEnabler(group) {
      return (group.options || []).find(o => o.type === 'enabler') || null;
    },

    isEnabled(group) {
      const enabler = this.getEnabler(group);
      if (!enabler) return true;
      const val = this.getVal(group.section, enabler.name);
      return val === true || val === 'True' || val === '1' || val === 1 || val === 'true';
    },

    toggleEnabler(group) {
      const enabler = this.getEnabler(group);
      if (!enabler) return;
      const newVal = !this.isEnabled(group);
      this.setVal(group.section, enabler.name, newVal);
      // Auto-expand when enabling, collapse when disabling
      const groups = this.currentGroups;
      const idx = groups.indexOf(group);
      if (idx >= 0) {
        const key = this.groupKey(group, idx);
        this.openGroups[key] = newVal;
      }
    },

    getVal(section, name) {
      const key = section + '.' + name;
      if (key in this.dirty) return this.dirty[key];
      if (this.values[section] && this.values[section][name] !== undefined) {
        return this.values[section][name];
      }
      return '';
    },

    setVal(section, name, value) {
      const key = section + '.' + name;
      this.dirty[key] = value;
    },

    toggleGroup(key) {
      this.openGroups[key] = !this.openGroups[key];
    },

    isGroupOpen(key) {
      return !!this.openGroups[key];
    },

    async saveAll() {
      this.saving = true;
      let restartNeeded = false;
      try {
        const saves = Object.entries(this.dirty).map(([key, value]) => {
          const [section, ...nameParts] = key.split('.');
          const name = nameParts.join('.');
          const params = new URLSearchParams();
          params.append('section', section);
          params.append('name', name);
          params.append('value', typeof value === 'boolean' ? (value ? '1' : '0') : String(value));
          return fetch(CP.apiBase + '/settings.save/?' + params.toString());
        });
        await Promise.all(saves);
        for (const [key, value] of Object.entries(this.dirty)) {
          const [section, ...nameParts] = key.split('.');
          const name = nameParts.join('.');
          if (!this.values[section]) this.values[section] = {};
          this.values[section][name] = value;
        }
        const restartKeys = ['core.port', 'core.ssl_cert', 'core.ssl_key', 'core.username', 'core.password'];
        restartNeeded = Object.keys(this.dirty).some(k => restartKeys.includes(k));
        this.dirty = {};
        this.toast('Settings saved!', 'success');
        if (restartNeeded) this.needsRestart = true;
      } catch (e) {
        this.toast('Failed to save: ' + e.message, 'error');
      }
      this.saving = false;
    },

    async testProvider(group) {
      this.testing = group.section;
      this.testResult[group.section] = '';
      this.testResultDetails[group.section] = null;
      try {
        // Route to correct API endpoint based on provider type
        let endpoint;
        if (group.list === 'download_providers') {
          endpoint = 'download.' + group.section + '.test';
        } else if (group.list === 'notification_providers') {
          endpoint = 'notify.' + group.section + '.test';
        } else if (group.list === 'nzb_providers' || group.list === 'torrent_providers') {
          endpoint = 'provider.' + group.section + '.test';
        } else {
          // Fallback for other provider types
          endpoint = group.section + '.test';
        }
        const resp = await fetch(CP.apiBase + '/' + endpoint + '/');
        const data = await resp.json();

        // Check if message contains multiple results (semicolon-separated for multi-entry providers)
        const msg = data.message || data.msg || '';
        if (!data.success && msg.includes(';')) {
          // Parse individual results from message like "host1: OK; host2: error"
          const details = msg.split(';').map(part => {
            const trimmed = part.trim();
            const colonIdx = trimmed.indexOf(':');
            if (colonIdx > 0) {
              const host = trimmed.substring(0, colonIdx).trim();
              const result = trimmed.substring(colonIdx + 1).trim();
              const success = result.toLowerCase() === 'ok' || result.toLowerCase() === 'connected';
              return { host, success, error: success ? null : result };
            }
            return { host: trimmed, success: false, error: trimmed };
          });
          this.testResultDetails[group.section] = details;
          const successCount = details.filter(d => d.success).length;
          this.testResult[group.section] = successCount + '/' + details.length + ' passed';
        } else if (data.success && msg.includes(';')) {
          // All passed but still show details
          const details = msg.split(';').map(part => {
            const trimmed = part.trim();
            const colonIdx = trimmed.indexOf(':');
            const host = colonIdx > 0 ? trimmed.substring(0, colonIdx).trim() : trimmed;
            return { host, success: true, error: null };
          });
          this.testResultDetails[group.section] = details;
          this.testResult[group.section] = 'success';
        } else {
          this.testResult[group.section] = data.success ? 'success' : (msg || 'failed');
        }
      } catch (e) {
        this.testResult[group.section] = 'error';
      }
      this.testing = null;
    },

    async restartApp() {
      try {
        await fetch(CP.apiBase + '/app.restart/');
        this.toast('Restarting…', 'success');
        this.needsRestart = false;
        setTimeout(() => location.reload(), 5000);
      } catch (e) {
        this.toast('Restart failed', 'error');
      }
    },

    toast(msg, type) {
      this.message = msg;
      this.messageType = type;
      setTimeout(() => this.message = '', 3000);
    },
  };
}

/* ── Button field (action buttons like Jackett sync) ── */
function buttonField(section, opt) {
  return {
    running: false,
    result: '',
    success: false,
    section,
    opt,

    async execute() {
      if (!opt.button_action) {
        this.result = 'No action configured';
        this.success = false;
        return;
      }

      this.running = true;
      this.result = '';

      try {
        const endpoint = opt.button_action;
        const resp = await fetch(CP.apiBase + '/' + endpoint + '/');
        const data = await resp.json();

        this.success = data.success === true;
        if (data.success) {
          this.result = data.message || 'Success';
          // Reload settings to reflect any changes made by the action
          const panel = this.getPanel();
          if (panel) {
            setTimeout(() => panel.init(), 500);
          }
        } else {
          this.result = data.error || data.message || 'Failed';
        }
      } catch (e) {
        this.success = false;
        this.result = 'Error: ' + e.message;
      }

      this.running = false;
    },

    getPanel() {
      let el = this.$el;
      while (el && !el.__x_panel) el = el.parentElement;
      if (!el) {
        el = document.querySelector('[x-data="settingsPanel()"]');
      }
      return el ? Alpine.$data(el) : null;
    },
  };
}

/* ── Combined field (multi-row entries like newznab hosts/keys) ── */
function combinedField(section, opt) {
  return {
    rows: [],
    section,
    opt,
    init() {
      const panel = this.getPanel();
      // Parse comma-separated values for each column
      const cols = opt.combine || [];
      const colVals = cols.map(col => {
        const raw = panel.getVal(section, col) || '';
        return String(raw).split(',').map(s => s.trim());
      });
      const maxRows = Math.max(1, ...colVals.map(c => c.length));
      this.rows = [];
      for (let i = 0; i < maxRows; i++) {
        this.rows.push(cols.map((_, ci) => colVals[ci][i] || ''));
      }
    },
    getPanel() {
      let el = this.$el;
      while (el && !el.__x_panel) el = el.parentElement;
      // Fallback: walk up to [x-data="settingsPanel()"]
      if (!el) {
        el = document.querySelector('[x-data="settingsPanel()"]');
      }
      return el ? Alpine.$data(el) : null;
    },
    sync() {
      const panel = this.getPanel();
      if (!panel) return;
      const cols = this.opt.combine || [];
      cols.forEach((col, ci) => {
        const val = this.rows.map(r => r[ci] || '').join(',');
        panel.setVal(this.section, col, val);
      });
    },
    updateRow(rowIdx, colIdx, value) {
      this.rows[rowIdx][colIdx] = value;
      this.sync();
    },
    addRow() {
      this.rows.push(this.opt.combine.map(() => ''));
    },
    removeRow(idx) {
      if (this.rows.length > 1) {
        this.rows.splice(idx, 1);
        this.sync();
      }
    },
  };
}

/* ── Directories field (multi-path) ── */
function directoriesField(section, opt) {
  return {
    dirs: [],
    section,
    opt,
    init() {
      const panel = this.getPanel();
      const raw = panel ? panel.getVal(section, opt.name) : '';
      // CouchPotato uses :: as delimiter for directories
      const parts = String(raw || '').split('::').filter(s => s.trim());
      this.dirs = parts.length ? parts : [''];
    },
    getPanel() {
      let el = this.$el;
      while (el && !el.__x_panel) el = el.parentElement;
      if (!el) el = document.querySelector('[x-data="settingsPanel()"]');
      return el ? Alpine.$data(el) : null;
    },
    sync() {
      const panel = this.getPanel();
      if (!panel) return;
      const val = this.dirs.filter(d => d.trim()).join('::');
      panel.setVal(this.section, this.opt.name, val);
    },
    updateDir(idx, value) {
      this.dirs[idx] = value;
      this.sync();
    },
    addDir() {
      this.dirs.push('');
    },
    removeDir(idx) {
      if (this.dirs.length > 1) {
        this.dirs.splice(idx, 1);
        this.sync();
      }
    },
  };
}
</script>
{% endblock %}
