{% extends "base.html" %}
{% block title %}Settings — CouchPotato{% endblock %}
{% block content %}
<div class="p-4 lg:p-8 fade-in" x-data="settingsPanel()" x-init="init()">
  <div class="flex items-center justify-between mb-6">
    <div class="flex items-center gap-3">
      <h1 class="text-xl font-semibold tracking-tight">Settings</h1>
      <span x-show="version" class="text-[10px] text-cp-muted bg-white/[0.04] px-2 py-0.5 rounded" x-text="'v' + version"></span>
    </div>
    <div class="flex items-center gap-3">
      <template x-if="activeTab !== 'logs'">
        <label class="flex items-center gap-2 cursor-pointer text-xs text-cp-muted">
          <button @click="showAdvanced = !showAdvanced"
                  :class="showAdvanced ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                  class="relative w-8 h-4 rounded-full transition-colors shrink-0">
            <span :class="showAdvanced ? 'translate-x-4' : 'translate-x-0.5'"
                  class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
          </button>
          <span :class="showAdvanced ? 'text-cp-accent' : ''">Advanced</span>
        </label>
      </template>
      <template x-if="activeTab !== 'logs'">
        <a href="{{ new_base }}wizard/" class="px-4 py-1.5 rounded-md text-xs font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors flex items-center gap-1.5">
          <svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.894 20.567L16.5 21.75l-.394-1.183a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 001.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 001.423 1.423l1.183.394-1.183.394a2.25 2.25 0 00-1.423 1.423z"/>
          </svg>
          Setup Wizard
        </a>
      </template>
      <!-- Auto-save indicator (replaces Save button) -->
      <template x-if="activeTab !== 'logs'">
        <div class="flex items-center gap-2 text-xs">
          <span x-show="saving" class="flex items-center gap-1.5 text-cp-muted">
            <svg class="w-3 h-3 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
            Saving…
          </span>
          <span x-show="lastSaved && !saving" class="text-cp-success flex items-center gap-1">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
            Saved
          </span>
        </div>
      </template>
    </div>
  </div>

  <!-- Loading state -->
  <div x-show="loading" class="flex items-center justify-center py-20">
    <div class="flex items-center gap-3 text-cp-muted text-sm">
      <svg class="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
      Loading settings…
    </div>
  </div>

  <div x-show="!loading" x-cloak>
    <!-- Tabs -->
    <div class="flex flex-wrap gap-1 mb-6 overflow-x-auto scrollbar-hide">
      <template x-for="tab in tabOrder" :key="tab">
        <button @click="activeTab = tab"
                :class="activeTab === tab ? 'bg-cp-accent text-white shadow-md' : 'bg-white/[0.06] text-cp-muted hover:text-cp-text hover:bg-white/[0.10]'"
                class="px-4 py-2 rounded-lg transition-all text-sm font-medium" x-text="tabLabels[tab] || tab"></button>
      </template>
    </div>

    <!-- ==================== LOGS TAB ==================== -->
    <div x-show="activeTab === 'logs'" x-data="logsPanel()" x-init="$watch('$root.activeTab', v => { if(v==='logs') init(); else stopAutoRefresh(); })">
      <div class="flex items-center gap-3 mb-4">
        <select x-model="logType" @change="refresh()"
                class="bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
          <option value="all">All</option>
          <option value="error">Errors</option>
          <option value="warning">Warnings</option>
          <option value="info">Info</option>
          <option value="debug">Debug</option>
        </select>
        <label class="flex items-center gap-2 cursor-pointer text-xs text-cp-muted">
          <input type="checkbox" x-model="autoRefresh" @change="toggleAutoRefresh()"
                 class="rounded border-white/[0.1] bg-white/[0.03] text-cp-accent focus:ring-cp-accent/30">
          Auto-refresh
        </label>
        <button @click="refresh()" class="px-3 py-1.5 rounded-md text-xs font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors">
          Refresh
        </button>
        <button @click="clearLogs()" class="px-3 py-1.5 rounded-md text-xs font-medium bg-cp-danger/10 text-cp-danger hover:bg-cp-danger/20 transition-colors">
          Clear
        </button>
      </div>

      <div x-show="logLoading && logs.length === 0" class="flex items-center justify-center py-20">
        <div class="flex items-center gap-3 text-cp-muted text-sm">
          <svg class="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
          Loading logs…
        </div>
      </div>

      <div class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden font-mono text-[11px] leading-relaxed">
        <div class="max-h-[calc(100vh-280px)] overflow-y-auto" id="log-container">
          <template x-if="logs.length === 0 && !logLoading">
            <div class="px-4 py-8 text-center text-cp-muted text-xs">No log entries found.</div>
          </template>
          <template x-for="(entry, idx) in logs" :key="idx">
            <div class="px-4 py-1.5 border-b border-white/[0.02] hover:bg-white/[0.02] transition-colors"
                 :class="{
                   'text-cp-danger bg-cp-danger/[0.03]': entry.type === 'ERROR',
                   'text-cp-warning bg-cp-warning/[0.03]': entry.type === 'WARNING',
                   'text-cp-text': entry.type === 'INFO',
                   'text-cp-muted': entry.type === 'DEBUG',
                 }">
              <span class="text-cp-muted/50 select-none" x-text="entry.time"></span>
              <span class="inline-block w-14 text-center font-medium"
                    :class="{
                      'text-cp-danger': entry.type === 'ERROR',
                      'text-cp-warning': entry.type === 'WARNING',
                      'text-cp-accent': entry.type === 'INFO',
                      'text-cp-muted': entry.type === 'DEBUG',
                    }" x-text="entry.type"></span>
              <span class="text-cp-muted/70" x-text="'[' + entry.source + ']'"></span>
              <span x-text="entry.message"></span>
            </div>
          </template>
        </div>
      </div>
    </div>

    <!-- ==================== SETTINGS TABS ==================== -->
    <div x-show="activeTab !== 'logs'" class="space-y-4">
      <template x-for="(group, groupIdx) in currentGroups" :key="groupIdx">
        <div x-show="!group.advanced || showAdvanced">
          <!-- Category header (visual grouping) -->
          <template x-if="shouldShowCategoryHeader(groupIdx)">
            <div class="flex items-center gap-3 mb-3" :class="groupIdx > 0 ? 'mt-6' : ''">
              <h2 class="text-sm font-semibold text-cp-text" x-text="getCategoryLabel(groupIdx)"></h2>
              <div class="flex-1 h-px bg-white/[0.06]"></div>
            </div>
          </template>
          
          <!-- ===== COMBINED BASICS CARD (searcher tab) ===== -->
          <template x-if="group._isCombined">
            <div class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden max-w-full">
              <div class="px-5 py-3 border-b border-white/[0.04]">
                <h3 class="text-sm font-medium" x-text="group.label"></h3>
              </div>
              <div class="px-5 py-4 space-y-6">
                <template x-for="(subGroup, subIdx) in group._combinedGroups" :key="subIdx">
                  <div>
                    <!-- Sub-section heading -->
                    <h4 class="text-xs font-semibold text-cp-accent uppercase tracking-wide mb-3" x-text="subGroup._subLabel"></h4>
                    <p x-show="subGroup.description" class="text-[11px] text-cp-muted mb-3" x-html="subGroup.description"></p>
                    <!-- Sub-section options -->
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4">
                      <template x-for="opt in getGroupOptions(subGroup)" :key="subGroup.section + '.' + opt.name">
                        <div x-show="opt.type !== 'enabler' && isOptionVisible(opt, subGroup)"
                             :class="(opt.type === 'directory' || opt.type === 'directories' || opt.type === 'combined' || opt.type === 'button') ? 'sm:col-span-2' : ''">
                          <label class="block text-xs text-cp-muted mb-1.5" x-text="opt.label || opt.name.replace(/_/g, ' ')"></label>
                          <!-- Dropdown -->
                          <template x-if="opt.type === 'dropdown'">
                            <div>
                              <select @change="setVal(subGroup.section, opt.name, $event.target.value)"
                                      class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                                <template x-for="v in (opt.values || [])" :key="JSON.stringify(v)">
                                  <option :value="Array.isArray(v) ? v[1] : v"
                                          :selected="String(getVal(subGroup.section, opt.name)) === String(Array.isArray(v) ? v[1] : v)"
                                          x-text="Array.isArray(v) ? v[0] : v"></option>
                                </template>
                              </select>
                              <p class="text-[10px] text-cp-muted/60 mt-1.5" x-html="buildDescription(subGroup.section, opt)"></p>
                            </div>
                          </template>
                          <!-- Int -->
                          <template x-if="opt.type === 'int' || opt.type === 'float'">
                            <div>
                              <input type="number" :step="opt.type === 'float' ? '0.1' : '1'"
                                     :value="getVal(subGroup.section, opt.name)"
                                     @input="setVal(subGroup.section, opt.name, $event.target.value)"
                                     class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                              <p class="text-[10px] text-cp-muted/60 mt-1.5" x-html="buildDescription(subGroup.section, opt)"></p>
                            </div>
                          </template>
                          <!-- Text (default) -->
                          <template x-if="!opt.type || opt.type === 'string'">
                            <div>
                              <input type="text"
                                     :value="getVal(subGroup.section, opt.name)"
                                     @input="setVal(subGroup.section, opt.name, $event.target.value)"
                                     :placeholder="opt.placeholder || (opt.default != null ? String(opt.default) : '')"
                                     class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                              <p class="text-[10px] text-cp-muted/60 mt-1.5" x-html="buildDescription(subGroup.section, opt)"></p>
                            </div>
                          </template>
                        </div>
                      </template>
                    </div>
                  </div>
                </template>
              </div>
            </div>
          </template>
          
          <!-- ===== REGULAR PROVIDER CARD ===== -->
          <template x-if="!group._isCombined">
          <div class="bg-cp-card rounded-lg border border-white/[0.05] overflow-hidden max-w-full">
            <!-- Group header -->
            <div class="flex items-center justify-between px-5 py-3"
                 :class="[
                   isGroupOpen(groupKey(group, groupIdx)) && (getEnabler(group) ? isEnabled(group) : true) ? 'border-b border-white/[0.04]' : '',
                   getEnabler(group) ? 'cursor-pointer' : ''
                 ]"
                 @click="getEnabler(group) && toggleGroup(groupKey(group, groupIdx))">
              <div class="flex items-center gap-3">
                <!-- Enabler toggle if group has one -->
                <template x-if="getEnabler(group)">
                  <button @click.stop="toggleEnabler(group)"
                          :class="isEnabled(group) ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                          class="relative w-8 h-4 rounded-full transition-colors shrink-0">
                    <span :class="isEnabled(group) ? 'translate-x-4' : 'translate-x-0.5'"
                          class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
                  </button>
                </template>
                <div>
                  <h3 class="text-sm font-medium" x-text="group.label || group.name"></h3>
                  <p x-show="group.description" class="text-[11px] text-cp-muted mt-0.5" x-html="group.description"></p>
                </div>
              </div>
              <!-- Only show chevron for groups with enabler (collapsible) -->
              <template x-if="getEnabler(group)">
                <svg class="w-4 h-4 text-cp-muted transition-transform" :class="isGroupOpen(groupKey(group, groupIdx)) ? 'rotate-180' : ''" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"/>
                </svg>
              </template>
            </div>

            <!-- Group options: always visible for non-enabler groups, toggle for enabler groups -->
            <div x-show="getEnabler(group) ? isGroupOpen(groupKey(group, groupIdx)) : true" x-transition class="px-5 py-4 overflow-hidden">
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4 overflow-hidden">
                <template x-for="opt in getGroupOptions(group)" :key="group.section + '.' + opt.name">
                  <div x-show="opt.type !== 'enabler' && (showAdvanced || !opt.advanced) && isOptionVisible(opt, group)"
                       :class="(opt.type === 'directory' || opt.type === 'directories' || opt.type === 'combined' || opt.type === 'button') ? 'sm:col-span-2' : ''">
                    <label x-show="opt.type !== 'combined'" class="block text-xs text-cp-muted mb-1.5" x-text="opt.label || opt.name.replace(/_/g, ' ')"></label>

                    <!-- Bool / checkbox -->
                    <template x-if="opt.type === 'bool'">
                      <div>
                        <label class="flex items-center gap-2 cursor-pointer">
                          <input type="checkbox"
                                 :checked="getVal(group.section, opt.name)"
                                 @change="setVal(group.section, opt.name, $event.target.checked)"
                                 class="rounded border-white/[0.1] bg-white/[0.03] text-cp-accent focus:ring-cp-accent/30">
                          <span class="text-[11px] text-cp-muted" x-html="buildDescription(group.section, opt)"></span>
                        </label>
                        <!-- Learn more expandable -->
                        <template x-if="hasLearnMore(group.section, opt.name)">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore(group.section, opt.name)"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Dropdown -->
                    <template x-if="opt.type === 'dropdown'">
                      <div>
                        <select @change="setVal(group.section, opt.name, $event.target.value)"
                                class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                          <template x-for="v in (opt.values || [])" :key="JSON.stringify(v)">
                            <option :value="Array.isArray(v) ? v[1] : v"
                                    :selected="String(getVal(group.section, opt.name)) === String(Array.isArray(v) ? v[1] : v)"
                                    x-text="Array.isArray(v) ? v[0] : v"></option>
                          </template>
                        </select>
                        <p class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription(group.section, opt)"></p>
                        <template x-if="hasLearnMore(group.section, opt.name)">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore(group.section, opt.name)"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Password -->
                    <template x-if="opt.type === 'password'">
                      <div>
                        <input type="password"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription(group.section, opt)"></p>
                        <template x-if="hasLearnMore(group.section, opt.name)">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore(group.section, opt.name)"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Int -->
                    <template x-if="opt.type === 'int' || opt.type === 'float'">
                      <div>
                        <input type="number" :step="opt.type === 'float' ? '0.1' : '1'"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription(group.section, opt)"></p>
                        <template x-if="hasLearnMore(group.section, opt.name)">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore(group.section, opt.name)"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Button (action button like Jackett sync) -->
                    <template x-if="opt.type === 'button'">
                      <div x-data="buttonField(group.section, opt)">
                        <button @click="execute()" :disabled="running"
                                class="px-4 py-2 rounded-md text-xs font-medium bg-cp-accent/20 text-cp-accent hover:bg-cp-accent/30 transition-colors disabled:opacity-50">
                          <span x-show="!running" x-text="opt.button_text || 'Execute'"></span>
                          <span x-show="running" class="flex items-center gap-2">
                            <svg class="w-3 h-3 animate-spin" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
                            Running…
                          </span>
                        </button>
                        <div x-show="result" class="mt-2 text-xs" :class="success ? 'text-cp-success' : 'text-cp-danger'" x-text="result"></div>
                        <p class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="$root.buildDescription(group.section, opt)"></p>
                      </div>
                    </template>

                    <!-- Combined (multi-entry rows like newznab hosts/keys) -->
                    <template x-if="opt.type === 'combined'">
                      <div x-data="combinedField(group.section, opt)">
                        <!-- Column headers -->
                        <div class="flex gap-2 mb-2 items-center text-[10px] text-cp-muted/60 font-medium">
                          <template x-for="(col, colIdx) in opt.combine" :key="'hdr-'+colIdx">
                            <span :class="col === 'use' ? 'w-10 shrink-0 text-center' : (col === 'host' ? 'flex-[2] min-w-0' : 'flex-1 min-w-0')" x-text="col === 'use' ? '' : col.replace(/_/g, ' ')"></span>
                          </template>
                          <span class="w-4 shrink-0"></span>
                        </div>
                        <template x-for="(row, rowIdx) in rows" :key="rowIdx">
                          <div class="flex gap-2 mb-2 items-center">
                            <template x-for="(col, colIdx) in opt.combine" :key="colIdx">
                              <div :class="col === 'use' ? 'w-10 shrink-0 flex justify-center' : (col === 'host' ? 'flex-[2] min-w-0' : 'flex-1 min-w-0')"
                                <!-- Toggle for 'use' column -->
                                <template x-if="col === 'use'">
                                  <button @click="updateRow(rowIdx, colIdx, (row[colIdx] === '1' || row[colIdx] === 1) ? '0' : '1')"
                                          :class="(row[colIdx] === '1' || row[colIdx] === 1) ? 'bg-cp-accent' : 'bg-white/[0.08]'"
                                          class="relative w-8 h-4 rounded-full transition-colors shrink-0">
                                    <span :class="(row[colIdx] === '1' || row[colIdx] === 1) ? 'translate-x-4' : 'translate-x-0.5'"
                                          class="block w-3 h-3 bg-white rounded-full transition-transform absolute top-0.5"></span>
                                  </button>
                                </template>
                                <!-- Text input for other columns -->
                                <template x-if="col !== 'use'">
                                  <input type="text" :placeholder="col.replace(/_/g, ' ')"
                                         :value="row[colIdx] || ''"
                                         @input="updateRow(rowIdx, colIdx, $event.target.value)"
                                         class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
                                </template>
                              </div>
                            </template>
                            <button @click="removeRow(rowIdx)" class="text-cp-muted hover:text-cp-danger transition-colors shrink-0" title="Remove">
                              <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                          </div>
                        </template>
                        <button @click="addRow()" class="text-[11px] text-cp-accent hover:text-cp-accentHover transition-colors">+ Add</button>
                        <p x-show="buildDescription()" class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription()"></p>
                        <template x-if="hasLearnMore()">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore()"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Directories (multi-path) -->
                    <template x-if="opt.type === 'directories'">
                      <div class="sm:col-span-2" x-data="directoriesField(group.section, opt)">
                        <template x-for="(dir, dirIdx) in dirs" :key="dirIdx">
                          <div class="flex gap-2 mb-2 items-center">
                            <input type="text" :value="dir"
                                   @input="updateDir(dirIdx, $event.target.value)"
                                   placeholder="/path/to/movies"
                                   class="flex-1 bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-1.5 text-xs focus:outline-none focus:border-cp-accent/30">
                            <button @click="browseDir(dirIdx)" type="button"
                                    class="px-2 py-1.5 rounded-md text-xs bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors shrink-0">
                              Browse
                            </button>
                            <button @click="removeDir(dirIdx)" class="text-cp-muted hover:text-cp-danger transition-colors shrink-0" title="Remove">
                              <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                          </div>
                        </template>
                        <button @click="addDir()" class="text-[11px] text-cp-accent hover:text-cp-accentHover transition-colors">+ Add folder</button>
                        <p x-show="buildDescription()" class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription()"></p>
                        <template x-if="hasLearnMore()">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore()"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Directory (single path with browse) -->
                    <template x-if="opt.type === 'directory'">
                      <div>
                        <div class="flex gap-2">
                          <input type="text"
                                 :value="getVal(group.section, opt.name)"
                                 @input="setVal(group.section, opt.name, $event.target.value)"
                                 :placeholder="opt.default != null ? String(opt.default) : '/path/to/folder'"
                                 class="flex-1 bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                          <button @click="browseDirectory(group.section, opt.name)" type="button"
                                  class="px-3 py-2 rounded-md text-xs bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors shrink-0">
                            Browse
                          </button>
                        </div>
                        <p class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription(group.section, opt)"></p>
                        <template x-if="hasLearnMore(group.section, opt.name)">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore(group.section, opt.name)"></div>
                          </details>
                        </template>
                      </div>
                    </template>

                    <!-- Text (default) -->
                    <template x-if="!opt.type || opt.type === 'string'">
                      <div>
                        <input type="text"
                               :value="getVal(group.section, opt.name)"
                               @input="setVal(group.section, opt.name, $event.target.value)"
                               :placeholder="opt.default != null ? String(opt.default) : ''"
                               class="w-full bg-white/[0.03] border border-white/[0.06] rounded-md px-3 py-2 text-xs focus:outline-none focus:border-cp-accent/30">
                        <p class="text-[10px] text-cp-muted/60 mt-1.5 leading-relaxed" x-html="buildDescription(group.section, opt)"></p>
                        <template x-if="hasLearnMore(group.section, opt.name)">
                          <details class="mt-2 text-[10px]">
                            <summary class="text-cp-accent cursor-pointer hover:underline">Learn more</summary>
                            <div class="mt-1.5 p-2 rounded bg-white/[0.02] border border-white/[0.04] text-cp-muted leading-relaxed" x-html="getLearnMore(group.section, opt.name)"></div>
                          </details>
                        </template>
                      </div>
                    </template>
                  </div>
                </template>
              </div>

              <!-- Test button for providers -->
              <template x-if="group.list">
                <div class="mt-4 pt-3 border-t border-white/[0.04]">
                  <button @click="testProvider(group)" :disabled="testing === group.section"
                          class="px-3 py-1.5 rounded-md text-[11px] font-medium bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] transition-colors disabled:opacity-50">
                    <span x-show="testing !== group.section">Test <span x-text="group.label"></span></span>
                    <span x-show="testing === group.section">Testing…</span>
                  </button>
                  <!-- Simple result for single-entry providers -->
                  <span x-show="testResult[group.section] && !testResultDetails[group.section]"
                        :class="testResult[group.section] === 'success' ? 'text-cp-success' : 'text-cp-danger'"
                        class="ml-2 text-[11px]" x-text="testResult[group.section]"></span>
                  <!-- Detailed results for multi-entry providers -->
                  <div x-show="testResultDetails[group.section]" class="mt-2 space-y-1">
                    <template x-for="(detail, idx) in (testResultDetails[group.section] || [])" :key="idx">
                      <div class="flex items-center gap-2 text-[11px]">
                        <span :class="detail.success ? 'text-cp-success' : 'text-cp-danger'" class="shrink-0">
                          <template x-if="detail.success">✓</template>
                          <template x-if="!detail.success">✗</template>
                        </span>
                        <span class="text-cp-muted truncate" x-text="detail.host"></span>
                        <span x-show="detail.error" class="text-cp-danger/70 truncate" x-text="detail.error"></span>
                      </div>
                    </template>
                  </div>
                </div>
              </template>
            </div>
          </div>
          </template>
        </div>
      </template>
    </div>
  </div>

  <!-- Restart banner -->
  <div x-show="needsRestart" x-transition class="fixed bottom-4 left-1/2 -translate-x-1/2 z-50 flex items-center gap-3 px-5 py-3 rounded-lg bg-cp-warning/20 border border-cp-warning/30 backdrop-blur-sm">
    <span class="text-xs text-cp-warning font-medium">Some changes need a restart to take effect.</span>
    <button @click="restartApp()" class="px-3 py-1 rounded-md text-xs font-medium bg-cp-warning text-black hover:opacity-90 transition-opacity">Restart</button>
  </div>

  <!-- Toast -->
  <div x-show="message" x-transition class="fixed bottom-4 right-4 lg:bottom-8 lg:right-8 z-50 px-4 py-2 rounded-md text-xs font-medium"
       :class="messageType === 'success' ? 'bg-cp-success/20 text-cp-success' : 'bg-cp-danger/20 text-cp-danger'"
       x-text="message"></div>

  <!-- Directory Browser Modal -->
  <div x-show="browserOpen" x-transition class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div class="bg-cp-card rounded-xl border border-white/[0.05] w-full max-w-lg mx-4 max-h-[80vh] flex flex-col">
      <div class="px-4 py-3 border-b border-white/[0.04] flex items-center justify-between">
        <h3 class="text-sm font-medium">Browse Folders</h3>
        <button @click="browserOpen = false" class="text-cp-muted hover:text-cp-text">
          <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
        </button>
      </div>
      
      <div class="px-4 py-2 border-b border-white/[0.04] bg-white/[0.02]">
        <div class="flex items-center gap-2 text-xs">
          <button @click="loadDirectories(browserParent)" :disabled="browserIsRoot" 
                  class="px-2 py-1 rounded bg-white/[0.04] text-cp-muted hover:text-cp-text hover:bg-white/[0.06] disabled:opacity-30 disabled:cursor-not-allowed">
            ↑ Up
          </button>
          <span class="text-cp-muted font-mono truncate" x-text="browserPath"></span>
        </div>
      </div>
      
      <div class="flex-1 overflow-y-auto min-h-[200px] max-h-[400px]">
        <div x-show="browserLoading" class="flex items-center justify-center py-8">
          <svg class="w-4 h-4 animate-spin text-cp-muted" viewBox="0 0 24 24" fill="none"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/></svg>
        </div>
        <div x-show="!browserLoading && browserDirs.length === 0" class="py-8 text-center text-xs text-cp-muted">
          Empty folder
        </div>
        <template x-for="dir in browserDirs" :key="dir">
          <button @click="selectDirectory(dir)" 
                  class="w-full px-4 py-2 text-left text-xs hover:bg-white/[0.04] flex items-center gap-2 border-b border-white/[0.02]">
            <svg class="w-4 h-4 text-cp-accent shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z"/>
            </svg>
            <span class="truncate" x-text="dir.split('/').filter(Boolean).pop() || dir"></span>
          </button>
        </template>
      </div>
      
      <div class="px-4 py-3 border-t border-white/[0.04] flex justify-end gap-2">
        <button @click="browserOpen = false" class="px-4 py-2 rounded-md text-xs font-medium text-cp-muted hover:text-cp-text">Cancel</button>
        <button @click="confirmDirectory()" class="px-4 py-2 rounded-md text-xs font-medium bg-cp-accent text-black hover:bg-cp-accentHover">Select This Folder</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ── Logs panel (embedded in Settings) ── */
function logsPanel() {
  return {
    logs: [],
    logLoading: false,
    logType: 'all',
    autoRefresh: true,
    refreshTimer: null,

    async init() {
      await this.refresh();
      if (this.autoRefresh) this.startAutoRefresh();
    },

    async refresh() {
      this.logLoading = true;
      try {
        const typeParam = this.logType !== 'all' ? '&type=' + this.logType : '';
        const resp = await fetch(CP.apiBase + '/logging.partial/?limit=500' + typeParam);
        const data = await resp.json();
        if (data.success !== false) {
          this.logs = this.parseLogs(data.log || data.lines || []);
        }
      } catch (e) {
        console.error('Failed to load logs', e);
      }
      this.logLoading = false;
      this.$nextTick(() => {
        const el = document.getElementById('log-container');
        if (el) el.scrollTop = el.scrollHeight;
      });
    },

    parseLogs(lines) {
      if (!Array.isArray(lines)) return [];
      return lines.map(line => {
        if (typeof line === 'object' && line.time) {
          const msg = line.message || '';
          const srcMatch = msg.match(/^\[([^\]]*)\]\s*(.*)/);
          return {
            time: line.time,
            type: (line.type || 'INFO').toUpperCase(),
            source: srcMatch ? srcMatch[1].trim() : '',
            message: srcMatch ? srcMatch[2] : msg,
          };
        }
        if (typeof line !== 'string') return { time: '', type: 'INFO', source: '', message: String(line) };
        const m = line.match(/^(\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\s+(ERROR|WARNING|INFO|DEBUG)\s+\[([^\]]*)\]\s*(.*)$/);
        if (m) return { time: m[1], type: m[2], source: m[3].trim(), message: m[4] };
        const levelMatch = line.match(/\b(ERROR|WARNING|INFO|DEBUG)\b/);
        return { time: '', type: levelMatch ? levelMatch[1] : 'INFO', source: '', message: line };
      });
    },

    async clearLogs() {
      try {
        await fetch(CP.apiBase + '/logging.clear/');
        this.logs = [];
      } catch (e) {
        console.error('Failed to clear logs');
      }
    },

    startAutoRefresh() {
      this.stopAutoRefresh();
      this.refreshTimer = setInterval(() => this.refresh(), 10000);
    },

    stopAutoRefresh() {
      if (this.refreshTimer) {
        clearInterval(this.refreshTimer);
        this.refreshTimer = null;
      }
    },

    toggleAutoRefresh() {
      if (this.autoRefresh) this.startAutoRefresh();
      else this.stopAutoRefresh();
    },
  };
}

/* ── Settings panel ── */
function settingsPanel() {
  return {
    activeTab: 'general',
    loading: true,
    saving: false,
    showAdvanced: false,
    needsRestart: false,
    testing: null,
    testResult: {},
    testResultDetails: {},
    message: '',
    messageType: 'success',
    openGroups: {},
    options: {},
    values: {},
    dirty: {},
    tabOrder: [],
    currentGroups: [],
    // Auto-save state
    lastSaved: false,
    saveTimers: {},
    // Version info
    version: '',

    // Directory browser state
    browserOpen: false,
    browserPath: '/',
    browserDirs: [],
    browserLoading: false,
    browserTarget: null,  // { section, name, index? } for callback
    browserParent: '/',
    browserIsRoot: true,

    // Obsolete/dead sections to hide completely (defunct services)
    hiddenSections: new Set([
      'wdtvlive', 'windowsmediacenter', 'sonyps3', 'mediabrowser',
      'pneumatic', 'hadouken', 'homey',
      // Dead/defunct torrent trackers
      'awesomehd', 'bithdtv', 'scenetime', 'torrentbytes',
    ]),
    
    // Advanced-only sections (shown only when Advanced toggle is on)
    // Note: Downloaders and Searchers are NOT advanced - they're just less common
    advancedSections: new Set([
      // Currently empty - all providers visible by default
    ]),

    // Tabs to hide (no useful visible content)
    hiddenTabs: new Set(['providers', 'automation']),

    // Remap automation tab groups into suggestions (display) tab
    tabRemaps: { 'automation': 'display' },

    tabLabels: {
      general: 'General',
      downloaders: 'Downloaders',
      searcher: 'Searchers',
      renamer: 'Renamer',
      notifications: 'Notifications',
      manage: 'Library',
      display: 'Suggestions',
      providers: 'Providers',
      logs: 'Logs',
    },

    // Visual category groupings for cleaner organization
    providerCategories: {
      // Downloaders - Usenet Clients
      sabnzbd: { tab: 'downloaders', category: 'usenet', label: 'Usenet Clients', order: 1 },
      nzbget: { tab: 'downloaders', category: 'usenet', label: 'Usenet Clients', order: 1 },
      // Downloaders - Torrent Clients
      transmission: { tab: 'downloaders', category: 'torrent', label: 'Torrent Clients', order: 2 },
      qbittorrent: { tab: 'downloaders', category: 'torrent', label: 'Torrent Clients', order: 2 },
      deluge: { tab: 'downloaders', category: 'torrent', label: 'Torrent Clients', order: 2 },
      rtorrent: { tab: 'downloaders', category: 'torrent', label: 'Torrent Clients', order: 2 },
      utorrent: { tab: 'downloaders', category: 'torrent', label: 'Torrent Clients', order: 2 },
      // Downloaders - Other
      blackhole: { tab: 'downloaders', category: 'other', label: 'Other', order: 3 },
      putio: { tab: 'downloaders', category: 'other', label: 'Other', order: 3 },
      synology: { tab: 'downloaders', category: 'other', label: 'Other', order: 3 },
      // Searchers - Usenet Free
      binsearch: { tab: 'searcher', category: 'usenet-free', label: 'Usenet — Free', order: 10 },
      // Searchers - Usenet Account Required
      newznab: { tab: 'searcher', category: 'usenet-account', label: 'Usenet — Account Required', order: 11 },
      // Searchers - Torrent Free
      thepiratebay: { tab: 'searcher', category: 'torrent-free', label: 'Torrents — Free', order: 20 },
      yts: { tab: 'searcher', category: 'torrent-free', label: 'Torrents — Free', order: 20 },
      torrentpotato: { tab: 'searcher', category: 'torrent-free', label: 'Torrents — Free', order: 20 },
      // Searchers - Torrent Account Required
      iptorrents: { tab: 'searcher', category: 'torrent-account', label: 'Torrents — Account Required', order: 21 },
      passthepopcorn: { tab: 'searcher', category: 'torrent-account', label: 'Torrents — Account Required', order: 21 },
      alpharatio: { tab: 'searcher', category: 'torrent-account', label: 'Torrents — Account Required', order: 21 },
      hdbits: { tab: 'searcher', category: 'torrent-account', label: 'Torrents — Account Required', order: 21 },
      torrentday: { tab: 'searcher', category: 'torrent-account', label: 'Torrents — Account Required', order: 21 },
      torrentleech: { tab: 'searcher', category: 'torrent-account', label: 'Torrents — Account Required', order: 21 },
    },

    // Sections to combine into a single "Basics" card (searcher tab)
    // These will render as sub-sections with headings inside one card
    combinedBasicsSections: {
      'searcher': { tab: 'searcher', label: 'Basics', order: 1 },
      'nzb': { tab: 'searcher', label: 'NZB', order: 3 },
      'torrent': { tab: 'searcher', label: 'Torrents', order: 4 },
    },
    // The filter group is in 'searcher' section but separate group name
    combinedBasicsGroups: new Set(['searcher', 'filter']),

    // Rich contextual help for settings - supplements API descriptions
    settingHelp: {
      // === RENAMER ===
      'renamer.from': {
        description: 'The folder where CouchPotato looks for completed downloads.',
        whenToChange: 'Set this to your download client\'s "completed downloads" folder (e.g., where SABnzbd or qBittorrent saves finished files).',
        tip: 'Make sure CouchPotato has read/write access to this folder.',
      },
      'renamer.to': {
        description: 'Your main movie library folder where films are organized.',
        whenToChange: 'Point this to your Plex/Emby/Jellyfin media library, or wherever you want movies stored permanently.',
        tip: 'Movies will be moved here and renamed according to your folder/file naming rules.',
      },
      'renamer.folder_name': {
        description: 'How movie folders are named in your library.',
        whenToChange: 'Customize if your media server expects a specific format, or to include quality/year info.',
        defaultNote: 'Default "Moviename, The (2024)" works well with most media servers.',
      },
      'renamer.file_name': {
        description: 'How movie files are named inside their folders.',
        whenToChange: 'Usually the default works fine. Change if you want quality, codec, or other info in filenames.',
        defaultNote: 'Default "<thename><cd>.<ext>" produces clean names like "The Dark Knight.mkv".',
      },
      'renamer.run_every': {
        description: 'How often CouchPotato checks the download folder for new movies to process.',
        whenToChange: 'Lower values (1-5 min) for faster processing; higher values to reduce system load.',
        defaultNote: 'Default 1 minute is good for most setups.',
      },
      'renamer.force_every': {
        description: 'Interval for forced full scans of the download folder.',
        whenToChange: 'Increase if you have many files and want to reduce disk I/O.',
        defaultNote: 'Default 2 hours catches anything missed by normal scans.',
      },
      'renamer.next_on_failed': {
        description: 'When a download fails quality checks, automatically try the next best release.',
        whenToChange: 'Enable for hands-off operation. Disable if you prefer to manually choose alternatives.',
      },
      'renamer.move_leftover': {
        description: 'Move extra files (samples, screenshots, NFOs) along with the movie.',
        whenToChange: 'Enable if you want to keep extras. Disable for cleaner library folders.',
      },
      'renamer.cleanup': {
        description: 'Delete leftover files and empty folders after moving movies.',
        whenToChange: 'Enable to keep your download folder tidy. Disable if you want to review files manually first.',
      },
      'renamer.separator': {
        description: 'Character used between parts of the filename (e.g., spaces, dots, underscores).',
        whenToChange: 'Change if your media server or personal preference requires a specific format.',
      },
      'renamer.foldersep': {
        description: 'Character used between parts of the folder name.',
        whenToChange: 'Usually matches the file separator. Change for different folder vs file naming styles.',
      },
      'renamer.file_action': {
        description: 'What to do with movie files: move, copy, or create symbolic/hard links.',
        whenToChange: '<strong>Move</strong>: Most common, saves space.<br><strong>Copy</strong>: Keep original in downloads.<br><strong>Link</strong>: Advanced — allows seeding while having organized library.',
        learnMore: 'Symbolic links create a pointer to the original file. Hard links create a second reference to the same data on disk. Both allow your torrent client to continue seeding while your media server sees organized files. Links only work on the same filesystem.',
      },

      // === SEARCHER ===
      'searcher.cron_day': {
        description: 'Which day(s) to run the automated search for wanted movies.',
        whenToChange: 'Limit to specific days to reduce API calls, or set to "Every day" for fastest results.',
      },
      'searcher.cron_hour': {
        description: 'What hour(s) to run automated searches.',
        whenToChange: 'Spread across hours to avoid hitting provider rate limits. Or focus on off-peak hours.',
      },
      'searcher.always_search': {
        description: 'Search for movies immediately when added, even if not yet released.',
        whenToChange: 'Enable for pre-releases and early availability. Disable to reduce unnecessary searches.',
      },
      'searcher.run_on_launch': {
        description: 'Run a full search when CouchPotato starts.',
        whenToChange: 'Enable if CP runs intermittently. Disable if it\'s always running to avoid startup load.',
      },
      'searcher.search_on_add': {
        description: 'Immediately search for a movie when you add it to your wanted list.',
        whenToChange: 'Enable for instant gratification. Disable to batch searches into scheduled times.',
      },

      // === QUALITY ===
      'quality.order': {
        description: 'Priority order for quality types when searching.',
        whenToChange: 'Drag to reorder based on your preference. Higher = tried first.',
      },

      // === DOWNLOADERS (common patterns) ===
      'sabnzbd.host': {
        description: 'The URL where SABnzbd is running.',
        whenToChange: 'Update if SABnzbd is on a different machine or port.',
        defaultNote: 'Usually http://localhost:8080 for local installs.',
      },
      'sabnzbd.api_key': {
        description: 'API key for authenticating with SABnzbd.',
        whenToChange: 'Find this in SABnzbd → Config → General → API Key.',
        tip: 'Use the full API key, not the NZB key.',
      },
      'sabnzbd.category': {
        description: 'SABnzbd category for movie downloads.',
        whenToChange: 'Match this to a category configured in SABnzbd for proper post-processing paths.',
        defaultNote: 'Default "movies" works if you\'ve set up that category in SABnzbd.',
      },
      'qbittorrent.host': {
        description: 'The URL where qBittorrent Web UI is running.',
        whenToChange: 'Update if qBittorrent is on a different machine or port.',
        tip: 'Enable Web UI in qBittorrent: Tools → Options → Web UI.',
      },
      'transmission.host': {
        description: 'The URL where Transmission RPC is running.',
        whenToChange: 'Update if Transmission is on a different machine or port (default 9091).',
        tip: 'Enable remote access in Transmission preferences.',
      },

      // === CORE ===
      'core.username': {
        description: 'Username for logging into CouchPotato.',
        whenToChange: 'Set a username if CouchPotato is accessible from the internet.',
        tip: 'Leave blank to disable authentication (local-only setups).',
      },
      'core.password': {
        description: 'Password for logging into CouchPotato.',
        whenToChange: 'Required if you set a username. Use a strong, unique password.',
      },
      'core.port': {
        description: 'Network port CouchPotato runs on.',
        whenToChange: 'Change if port 5050 conflicts with another service.',
        tip: 'After changing, access CP at the new port (e.g., http://localhost:5051).',
      },
      'core.launch_browser': {
        description: 'Open a browser window when CouchPotato starts.',
        whenToChange: 'Disable for headless/server installs, or if it\'s annoying.',
      },
      'core.dark_theme': {
        description: 'Use the dark theme for the web interface.',
        whenToChange: 'Pure preference. Dark is easier on eyes at night.',
      },
      'core.development': {
        description: 'Enable development/debug mode.',
        whenToChange: 'Only enable when troubleshooting or developing. Increases logging and may affect performance.',
      },

      // === MANAGE/LIBRARY ===
      'manage.enabled': {
        description: 'Enable library management to track movies you already have.',
        whenToChange: 'Enable to see your collection in CP and track upgrades.',
      },
      'manage.library_refresh_interval': {
        description: 'How often to rescan your movie library for changes.',
        whenToChange: 'Increase for large libraries to reduce disk I/O.',
      },
      'manage.cleanup': {
        description: 'Remove movies from the database if their files are deleted.',
        whenToChange: 'Enable for automatic cleanup. Disable if you manually manage deletions.',
      },

      // === NOTIFICATIONS ===
      'pushover.on_snatch': {
        description: 'Send a notification when a movie starts downloading.',
        whenToChange: 'Enable to know immediately when downloads begin.',
      },
      'pushover.on_download': {
        description: 'Send a notification when a movie finishes downloading and is organized.',
        whenToChange: 'The most useful notification — tells you when a movie is ready to watch.',
      },
      'telegram.on_snatch': {
        description: 'Send a Telegram message when a movie starts downloading.',
        whenToChange: 'Enable if you want real-time download notifications.',
      },
      'telegram.on_download': {
        description: 'Send a Telegram message when a movie is ready.',
        whenToChange: 'The key notification — your movie is organized and ready to watch.',
      },

      // === TORRENTPOTATO / JACKETT ===
      'torrentpotato.jackett_url': {
        description: 'URL of your Jackett instance.',
        whenToChange: 'Point to where Jackett is running (e.g., http://localhost:9117).',
        tip: 'Jackett aggregates multiple torrent sites into one search endpoint.',
      },
      'torrentpotato.jackett_api_key': {
        description: 'API key from your Jackett configuration.',
        whenToChange: 'Find this in Jackett\'s web UI in the top right.',
      },
    },

    // Get enriched help for a setting
    getSettingHelp(section, optName) {
      const key = section + '.' + optName;
      return this.settingHelp[key] || null;
    },

    // Build the full description HTML for a setting
    buildDescription(section, opt) {
      const help = this.getSettingHelp(section, opt.name);
      const apiDesc = opt.description || '';
      
      if (!help) {
        return apiDesc;
      }

      let html = '';
      
      // Main description (prefer our help, fall back to API)
      const mainDesc = help.description || apiDesc;
      if (mainDesc) {
        html += mainDesc;
      }

      // When to change
      if (help.whenToChange) {
        html += '<br><span class="text-cp-accent/80">When to change:</span> ' + help.whenToChange;
      }

      // Default note
      if (help.defaultNote) {
        html += '<br><span class="text-cp-muted">💡 ' + help.defaultNote + '</span>';
      }

      // Tip
      if (help.tip) {
        html += '<br><span class="text-cp-warning/80">Tip:</span> ' + help.tip;
      }

      return html;
    },

    // Check if a setting has expandable "Learn more" content
    hasLearnMore(section, optName) {
      const help = this.getSettingHelp(section, optName);
      return help && help.learnMore;
    },

    // Get "Learn more" content
    getLearnMore(section, optName) {
      const help = this.getSettingHelp(section, optName);
      return help ? help.learnMore : '';
    },

    async init() {
      try {
        const resp = await fetch(CP.apiBase + '/settings/');
        const data = await resp.json();
        this.options = data.options || {};
        this.values = data.values || {};

        // Fetch version info
        try {
          const vResp = await fetch(CP.apiBase + '/updater.info/');
          const vData = await vResp.json();
          if (vData.version) {
            this.version = vData.version.repr || vData.version.hash?.substring(0,7) || '';
          }
        } catch (e) { /* version display is optional */ }

        // Determine tab order from the data
        const tabSet = new Set();
        const tabOrderMap = {};
        for (const [sectionName, section] of Object.entries(this.options)) {
          if (this.hiddenSections.has(sectionName)) continue;
          for (const grp of (section.groups || [])) {
            const tab = grp.tab || 'general';
            tabSet.add(tab);
            if (section.order && (!tabOrderMap[tab] || section.order < tabOrderMap[tab])) {
              tabOrderMap[tab] = section.order;
            }
          }
        }

        const preferred = ['general', 'searcher', 'downloaders', 'renamer', 'notifications', 'automation', 'manage', 'display'];
        this.tabOrder = preferred.filter(t => tabSet.has(t) && !this.hiddenTabs.has(t));
        for (const t of tabSet) {
          if (!this.tabOrder.includes(t) && !this.hiddenTabs.has(t)) this.tabOrder.push(t);
        }
        // Add Logs tab at the end
        this.tabOrder.push('logs');

        // Smart auto-expand: essential settings visible, enabled sections open
        this.computeOpenGroups();
        this.updateCurrentGroups();
      } catch (e) {
        console.error('Failed to load settings', e);
        this.toast('Failed to load settings', 'error');
      }
      this.loading = false;
      this.$watch('activeTab', () => this.updateCurrentGroups());
      this.$watch('showAdvanced', () => this.updateCurrentGroups());
    },

    computeOpenGroups() {
      for (const tab of this.tabOrder) {
        const groups = this.getTabGroups(tab);
        groups.forEach((group, idx) => {
          const key = this.groupKey(group, idx);
          const enabler = this.getEnabler(group);
          if (!enabler) {
            // No enabler = always open (not collapsible)
            this.openGroups[key] = true;
          } else if (this.isEnabled(group)) {
            // Has enabler and ON = expand to show options
            this.openGroups[key] = true;
          }
          // Enabler OFF = collapsed, just shows the toggle
        });
      }
    },

    updateCurrentGroups() {
      this.currentGroups = this.getTabGroups(this.activeTab);
    },

    groupKey(group, idx) {
      return group.section + '.' + (group.name || 'default') + '.' + (idx || 0);
    },

    getTabGroups(tab) {
      const groups = [];
      const combinedGroups = []; // For searcher basics combined card
      
      for (const [sectionName, section] of Object.entries(this.options)) {
        if (this.hiddenSections.has(sectionName)) continue;
        // Skip advanced-only sections unless Advanced toggle is on
        if (this.advancedSections.has(sectionName) && !this.showAdvanced) continue;
        
        for (const grp of (section.groups || [])) {
          let originalTab = grp.tab || 'general';
          let grpTab = this.tabRemaps[originalTab] || originalTab;
          if (grpTab !== tab) continue;
          
          // Check if this should be part of the combined basics card (searcher tab only)
          const combineInfo = this.combinedBasicsSections[sectionName];
          if (tab === 'searcher' && combineInfo && combineInfo.tab === 'searcher') {
            // This is a basics/nzb/torrent section - add to combined card
            // Use the group's actual label (Basics, Global filters, NZB, Torrents)
            combinedGroups.push({
              ...grp,
              section: sectionName,
              order: combineInfo.order + (grp.name === 'filter' ? 0.5 : 0), // filter after basics
              _subLabel: grp.label || combineInfo.label,
              _isCombinedPart: true,
            });
            continue;
          }
          
          // Add category info if defined (for providers)
          const catInfo = this.providerCategories[sectionName];
          const category = catInfo ? catInfo.category : 'zzz'; // uncategorized last
          const categoryLabel = catInfo ? catInfo.label : null;
          const categoryOrder = catInfo ? catInfo.order : 99;
          groups.push({ 
            ...grp, 
            section: sectionName, 
            order: section.order || 999, 
            _originalTab: originalTab,
            _category: category,
            _categoryLabel: categoryLabel,
            _categoryOrder: categoryOrder,
          });
        }
      }
      
      // Sort provider groups by category order first, then by section order
      groups.sort((a, b) => {
        if (a._categoryOrder !== b._categoryOrder) return a._categoryOrder - b._categoryOrder;
        return a.order - b.order;
      });
      
      // If we have combined groups (searcher tab), add them as a single combined card at the top
      if (combinedGroups.length > 0) {
        combinedGroups.sort((a, b) => a.order - b.order);
        const combinedCard = {
          name: '_combined_basics',
          label: 'Search Settings',
          section: '_combined',
          _isCombined: true,
          _combinedGroups: combinedGroups,
          _categoryOrder: 0, // Always first
          order: 0,
        };
        return [combinedCard, ...groups];
      }
      
      return groups;
    },

    // Check if we should show a category header before this group
    shouldShowCategoryHeader(groupIdx) {
      const groups = this.currentGroups;
      const group = groups[groupIdx];
      if (!group || !group._categoryLabel) return false;
      if (groupIdx === 0) return true;
      const prev = groups[groupIdx - 1];
      return prev._category !== group._category;
    },

    getCategoryLabel(groupIdx) {
      const group = this.currentGroups[groupIdx];
      return group ? group._categoryLabel : '';
    },

    getGroupOptions(group) {
      // Collect names consumed by combined fields so they can be hidden
      const combinedNames = new Set();
      for (const opt of (group.options || [])) {
        if (opt.type === 'combined' && opt.combine) {
          for (const col of opt.combine) {
            if (col !== opt.name) combinedNames.add(col);
          }
        }
      }
      return (group.options || [])
        .filter(opt => !combinedNames.has(opt.name))
        .map(opt => ({
          ...opt,
          label: opt.label || null,
        }));
    },

    isOptionVisible(opt, group) {
      if (!opt.show_when) return true;
      // Touch dirty to make Alpine reactive to changes
      const _dirty = JSON.stringify(this.dirty);
      for (const [key, expected] of Object.entries(opt.show_when)) {
        const [sec, name] = key.split('.');
        const val = this.getVal(sec, name);
        const boolVal = val === true || val === 'True' || val === '1' || val === 1 || val === 'true';
        if (expected === true && !boolVal) return false;
        if (expected === false && boolVal) return false;
        if (typeof expected !== 'boolean' && String(val) !== String(expected)) return false;
      }
      return true;
    },

    getEnabler(group) {
      return (group.options || []).find(o => o.type === 'enabler') || null;
    },

    isEnabled(group) {
      const enabler = this.getEnabler(group);
      if (!enabler) return true;
      const val = this.getVal(group.section, enabler.name);
      return val === true || val === 'True' || val === '1' || val === 1 || val === 'true';
    },

    toggleEnabler(group) {
      const enabler = this.getEnabler(group);
      if (!enabler) return;
      const newVal = !this.isEnabled(group);
      this.setVal(group.section, enabler.name, newVal);
      // Auto-expand when enabling, collapse when disabling
      const groups = this.currentGroups;
      const idx = groups.indexOf(group);
      if (idx >= 0) {
        const key = this.groupKey(group, idx);
        this.openGroups[key] = newVal;
      }
    },

    getVal(section, name) {
      const key = section + '.' + name;
      if (key in this.dirty) return this.dirty[key];
      if (this.values[section] && this.values[section][name] !== undefined) {
        return this.values[section][name];
      }
      return '';
    },

    setVal(section, name, value) {
      const key = section + '.' + name;
      this.dirty[key] = value;
      // Auto-save with debounce
      this.debounceSave(section, name, value);
    },

    debounceSave(section, name, value) {
      const key = section + '.' + name;
      // Clear existing timer for this key
      if (this.saveTimers[key]) {
        clearTimeout(this.saveTimers[key]);
      }
      // Set new timer - save after 500ms of no changes
      this.saveTimers[key] = setTimeout(() => {
        this.saveSingle(section, name, value);
      }, 500);
    },

    async saveSingle(section, name, value) {
      this.saving = true;
      this.lastSaved = false;
      try {
        const params = new URLSearchParams();
        params.append('section', section);
        params.append('name', name);
        params.append('value', typeof value === 'boolean' ? (value ? '1' : '0') : String(value));
        await fetch(CP.apiBase + '/settings.save/?' + params.toString());
        
        // Update local values cache
        if (!this.values[section]) this.values[section] = {};
        this.values[section][name] = value;
        
        // Remove from dirty
        const key = section + '.' + name;
        delete this.dirty[key];
        
        // Check if restart needed
        const restartKeys = ['core.port', 'core.ssl_cert', 'core.ssl_key', 'core.username', 'core.password'];
        if (restartKeys.includes(key)) {
          this.needsRestart = true;
        }
        
        this.lastSaved = true;
        // Hide "Saved" indicator after 2 seconds
        setTimeout(() => { this.lastSaved = false; }, 2000);
      } catch (e) {
        this.toast('Failed to save: ' + e.message, 'error');
      }
      this.saving = false;
    },

    toggleGroup(key) {
      this.openGroups[key] = !this.openGroups[key];
    },

    isGroupOpen(key) {
      return !!this.openGroups[key];
    },

    async saveAll() {
      this.saving = true;
      let restartNeeded = false;
      try {
        const saves = Object.entries(this.dirty).map(([key, value]) => {
          const [section, ...nameParts] = key.split('.');
          const name = nameParts.join('.');
          const params = new URLSearchParams();
          params.append('section', section);
          params.append('name', name);
          params.append('value', typeof value === 'boolean' ? (value ? '1' : '0') : String(value));
          return fetch(CP.apiBase + '/settings.save/?' + params.toString());
        });
        await Promise.all(saves);
        for (const [key, value] of Object.entries(this.dirty)) {
          const [section, ...nameParts] = key.split('.');
          const name = nameParts.join('.');
          if (!this.values[section]) this.values[section] = {};
          this.values[section][name] = value;
        }
        const restartKeys = ['core.port', 'core.ssl_cert', 'core.ssl_key', 'core.username', 'core.password'];
        restartNeeded = Object.keys(this.dirty).some(k => restartKeys.includes(k));
        this.dirty = {};
        this.toast('Settings saved!', 'success');
        if (restartNeeded) this.needsRestart = true;
      } catch (e) {
        this.toast('Failed to save: ' + e.message, 'error');
      }
      this.saving = false;
    },

    async testProvider(group) {
      this.testing = group.section;
      this.testResult[group.section] = '';
      this.testResultDetails[group.section] = null;
      try {
        // Route to correct API endpoint based on provider type
        let endpoint;
        if (group.list === 'download_providers') {
          endpoint = 'download.' + group.section + '.test';
        } else if (group.list === 'notification_providers') {
          endpoint = 'notify.' + group.section + '.test';
        } else if (group.list === 'nzb_providers' || group.list === 'torrent_providers') {
          endpoint = 'provider.' + group.section + '.test';
        } else {
          // Fallback for other provider types
          endpoint = group.section + '.test';
        }
        const resp = await fetch(CP.apiBase + '/' + endpoint + '/');
        const data = await resp.json();

        // Check if message contains multiple results (semicolon-separated for multi-entry providers)
        const msg = data.message || data.msg || '';
        if (!data.success && msg.includes(';')) {
          // Parse individual results from message like "host1: OK; host2: error"
          const details = msg.split(';').map(part => {
            const trimmed = part.trim();
            const colonIdx = trimmed.indexOf(':');
            if (colonIdx > 0) {
              const host = trimmed.substring(0, colonIdx).trim();
              const result = trimmed.substring(colonIdx + 1).trim();
              const success = result.toLowerCase() === 'ok' || result.toLowerCase() === 'connected';
              return { host, success, error: success ? null : result };
            }
            return { host: trimmed, success: false, error: trimmed };
          });
          this.testResultDetails[group.section] = details;
          const successCount = details.filter(d => d.success).length;
          this.testResult[group.section] = successCount + '/' + details.length + ' passed';
        } else if (data.success && msg.includes(';')) {
          // All passed but still show details
          const details = msg.split(';').map(part => {
            const trimmed = part.trim();
            const colonIdx = trimmed.indexOf(':');
            const host = colonIdx > 0 ? trimmed.substring(0, colonIdx).trim() : trimmed;
            return { host, success: true, error: null };
          });
          this.testResultDetails[group.section] = details;
          this.testResult[group.section] = 'success';
        } else {
          this.testResult[group.section] = data.success ? 'success' : (msg || 'failed');
        }
      } catch (e) {
        this.testResult[group.section] = 'error';
      }
      this.testing = null;
    },

    async restartApp() {
      try {
        await fetch(CP.apiBase + '/app.restart/');
        this.toast('Restarting…', 'success');
        this.needsRestart = false;
        setTimeout(() => location.reload(), 5000);
      } catch (e) {
        this.toast('Restart failed', 'error');
      }
    },

    toast(msg, type) {
      this.message = msg;
      this.messageType = type;
      setTimeout(() => this.message = '', 3000);
    },

    // Directory browser methods
    async browseDirectory(section, name, index = null) {
      this.browserTarget = { section, name, index };
      this.browserOpen = true;
      // Start from current value if set, otherwise root
      const currentVal = this.getVal(section, name);
      const startPath = (currentVal && typeof currentVal === 'string' && currentVal.startsWith('/')) ? currentVal : '/';
      this.browserPath = startPath;
      await this.loadDirectories(startPath);
    },

    async loadDirectories(path) {
      this.browserLoading = true;
      try {
        const resp = await fetch(CP.apiBase + '/directory.list/?path=' + encodeURIComponent(path));
        const data = await resp.json();
        this.browserPath = path;
        this.browserDirs = data.dirs || [];
        this.browserParent = data.parent;
        this.browserIsRoot = data.is_root;
      } catch (e) {
        console.error('Failed to load directories:', e);
        this.browserDirs = [];
      }
      this.browserLoading = false;
    },

    selectDirectory(dir) {
      this.loadDirectories(dir);
    },

    confirmDirectory() {
      const path = this.browserPath;
      if (this.browserTarget) {
        const { section, name, index } = this.browserTarget;
        if (index !== null) {
          // For directories field - dispatch custom event
          window.dispatchEvent(new CustomEvent('directory-selected', { 
            detail: { section, name, index, path } 
          }));
        } else {
          // For single directory field
          this.setVal(section, name, path);
        }
      }
      this.browserOpen = false;
    },
  };
}

/* ── Button field (action buttons like Jackett sync) ── */
function buttonField(section, opt) {
  return {
    running: false,
    result: '',
    success: false,
    section,
    opt,

    async execute() {
      if (!opt.button_action) {
        this.result = 'No action configured';
        this.success = false;
        return;
      }

      this.running = true;
      this.result = '';

      try {
        const endpoint = opt.button_action;
        const resp = await fetch(CP.apiBase + '/' + endpoint + '/');
        const data = await resp.json();

        this.success = data.success === true;
        if (data.success) {
          this.result = data.message || 'Success';
          // Reload settings to reflect any changes made by the action
          const panel = this.getPanel();
          if (panel) {
            setTimeout(() => panel.init(), 500);
          }
        } else {
          this.result = data.error || data.message || 'Failed';
        }
      } catch (e) {
        this.success = false;
        this.result = 'Error: ' + e.message;
      }

      this.running = false;
    },

    getPanel() {
      let el = this.$el;
      while (el && !el.__x_panel) el = el.parentElement;
      if (!el) {
        el = document.querySelector('[x-data="settingsPanel()"]');
      }
      return el ? Alpine.$data(el) : null;
    },
  };
}

/* ── Combined field (multi-row entries like newznab hosts/keys) ── */
function combinedField(section, opt) {
  return {
    rows: [],
    section,
    opt,
    init() {
      const panel = this.getPanel();
      // Parse comma-separated values for each column
      const cols = opt.combine || [];
      const colVals = cols.map(col => {
        const raw = panel.getVal(section, col) || '';
        return String(raw).split(',').map(s => s.trim());
      });
      const maxRows = Math.max(1, ...colVals.map(c => c.length));
      this.rows = [];
      for (let i = 0; i < maxRows; i++) {
        this.rows.push(cols.map((_, ci) => colVals[ci][i] || ''));
      }
    },
    getPanel() {
      let el = this.$el;
      while (el && !el.__x_panel) el = el.parentElement;
      // Fallback: walk up to [x-data="settingsPanel()"]
      if (!el) {
        el = document.querySelector('[x-data="settingsPanel()"]');
      }
      return el ? Alpine.$data(el) : null;
    },
    // Delegate to parent panel for description building
    buildDescription() {
      const panel = this.getPanel();
      return panel ? panel.buildDescription(this.section, this.opt) : (this.opt.description || '');
    },
    hasLearnMore() {
      const panel = this.getPanel();
      return panel ? panel.hasLearnMore(this.section, this.opt.name) : false;
    },
    getLearnMore() {
      const panel = this.getPanel();
      return panel ? panel.getLearnMore(this.section, this.opt.name) : '';
    },
    sync() {
      const panel = this.getPanel();
      if (!panel) return;
      const cols = this.opt.combine || [];
      cols.forEach((col, ci) => {
        const val = this.rows.map(r => r[ci] || '').join(',');
        panel.setVal(this.section, col, val);
      });
    },
    updateRow(rowIdx, colIdx, value) {
      this.rows[rowIdx][colIdx] = value;
      this.sync();
    },
    addRow() {
      this.rows.push(this.opt.combine.map(() => ''));
    },
    removeRow(idx) {
      if (this.rows.length > 1) {
        this.rows.splice(idx, 1);
        this.sync();
      }
    },
  };
}

/* ── Directories field (multi-path) ── */
function directoriesField(section, opt) {
  return {
    dirs: [],
    section,
    opt,
    _eventHandler: null,
    init() {
      const panel = this.getPanel();
      const raw = panel ? panel.getVal(section, opt.name) : '';
      // CouchPotato uses :: as delimiter for directories
      const parts = String(raw || '').split('::').filter(s => s.trim());
      this.dirs = parts.length ? parts : [''];
      
      // Listen for directory selection events
      this._eventHandler = (e) => {
        if (e.detail.section === this.section && e.detail.name === this.opt.name) {
          this.updateDir(e.detail.index, e.detail.path);
        }
      };
      window.addEventListener('directory-selected', this._eventHandler);
    },
    destroy() {
      if (this._eventHandler) {
        window.removeEventListener('directory-selected', this._eventHandler);
      }
    },
    getPanel() {
      let el = this.$el;
      while (el && !el.__x_panel) el = el.parentElement;
      if (!el) el = document.querySelector('[x-data="settingsPanel()"]');
      return el ? Alpine.$data(el) : null;
    },
    sync() {
      const panel = this.getPanel();
      if (!panel) return;
      const val = this.dirs.filter(d => d.trim()).join('::');
      panel.setVal(this.section, this.opt.name, val);
    },
    updateDir(idx, value) {
      this.dirs[idx] = value;
      this.sync();
    },
    addDir() {
      this.dirs.push('');
    },
    removeDir(idx) {
      if (this.dirs.length > 1) {
        this.dirs.splice(idx, 1);
        this.sync();
      }
    },
    browseDir(idx) {
      const panel = this.getPanel();
      if (panel) {
        panel.browseDirectory(this.section, this.opt.name, idx);
      }
    },
    // Delegate to parent panel for description building
    buildDescription() {
      const panel = this.getPanel();
      return panel ? panel.buildDescription(this.section, this.opt) : (this.opt.description || '');
    },
    hasLearnMore() {
      const panel = this.getPanel();
      return panel ? panel.hasLearnMore(this.section, this.opt.name) : false;
    },
    getLearnMore() {
      const panel = this.getPanel();
      return panel ? panel.getLearnMore(this.section, this.opt.name) : '';
    },
  };
}
</script>
{% endblock %}
